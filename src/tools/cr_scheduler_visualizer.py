"""CR Scheduler Visualizer
========================

Simple tool for visualizing CR gate schedules generated by the CR scheduler.
Outputs schedule statistics and visualization images for debugging and analysis.

This tool uses the CRScheduler class from the workflow engine and generates:
- Console output with schedule statistics
- Visualization images showing the schedule structure

Usage:
------
    python src/tools/cr_scheduler_visualizer.py

Outputs:
--------
- Console: Schedule statistics (number of groups, pairs per group, etc.)
- Files: Visualization plots in schedule_output/ directory
  - combined_schedule.png: All groups with color-coded edges
  - schedule_group_N.png: Individual group visualizations
"""

from pathlib import Path

import matplotlib.pyplot as plt
import networkx as nx
from qdash.dbmodel.initialize import initialize
from qdash.workflow.engine.calibration.cr_scheduler import CRScheduler

# ============================================================================
# Configuration Constants
# ============================================================================

DEFAULT_CHIP_ID = "64Qv3"
DEFAULT_USERNAME = "orangekame3"
SCHEDULE_OUTPUT_DIR = Path(".tmp/schedule_output")
LATTICE_DIMENSION = 4  # 4x4 unit cells
TOTAL_QUBITS = 64
MAX_PARALLEL_OPS = 10


# ============================================================================
# Visualization Functions
# ============================================================================


def correct_position(original: tuple[float, float], scale: float) -> tuple[float, float]:
    """Apply offset and scaling to lattice position coordinates."""
    return ((original[0] + 1/3) * scale, (original[1] + 10/3) * scale)


def qubit_lattice(n_qubits: int, dimension: int) -> dict[str, tuple[float, float]]:
    """Generate 2D lattice positions for qubits.

    Creates a 4x4 grid of unit cells, each containing 4 qubits.

    Args:
        n_qubits: Total number of qubits (typically 64)
        dimension: Lattice dimension (4 for 4x4 grid)

    Returns:
        Dictionary mapping qubit ID to (x, y) position
    """
    def node_id(i: int, j: int, k: int) -> int:
        """Calculate global qubit ID from cell indices and local position."""
        return 4 * (i * dimension + j) + k

    positions = {}
    for i in range(dimension):
        for j in range(dimension):
            # 4 qubits per unit cell arranged in a square
            positions[str(node_id(i, j, 0))] = correct_position((j - 1/3, -i + 1/3), 100)
            positions[str(node_id(i, j, 1))] = correct_position((j + 1/3, -i + 1/3), 100)
            positions[str(node_id(i, j, 2))] = correct_position((j - 1/3, -i - 1/3), 100)
            positions[str(node_id(i, j, 3))] = correct_position((j + 1/3, -i - 1/3), 100)

    return positions


def get_node_colors(graph: nx.Graph, qid_to_mux: dict[str, int]) -> list[tuple[float, ...]]:
    """Get node colors based on MUX assignment."""
    tab20 = plt.colormaps.get_cmap("tab20")
    return [tab20(qid_to_mux[qid] % 20) if qid in qid_to_mux else "gray" for qid in graph.nodes]


def visualize_combined_schedule(
    parallel_groups: list[list[tuple[str, str]]],
    qid_to_mux: dict[str, int],
    lattice_pos: dict[str, tuple[float, float]],
    output_path: Path = SCHEDULE_OUTPUT_DIR / "combined_schedule.png"
) -> None:
    """Create combined visualization showing all schedule steps with color-coded edges."""
    output_path.parent.mkdir(parents=True, exist_ok=True)

    # Build graph with color-coded edges
    graph = nx.Graph()
    edge_colors = []
    edge_labels = {}
    cmap = plt.colormaps.get_cmap("tab10")

    for group_idx, group in enumerate(parallel_groups):
        for control, target in group:
            graph.add_edge(control, target)
            edge_colors.append(cmap(group_idx % 10))
            edge_labels[(control, target)] = f"G{group_idx + 1}"

    graph.add_nodes_from(lattice_pos.keys())

    # Draw graph
    plt.figure(figsize=(12, 10))
    nx.draw(graph, pos=lattice_pos, node_color=get_node_colors(graph, qid_to_mux),
            edge_color=edge_colors, node_size=500, with_labels=True, font_size=8)
    nx.draw_networkx_edge_labels(graph, pos=lattice_pos, edge_labels=edge_labels, font_size=6)

    # Add legend
    group_handles = [plt.Line2D([0], [0], color=cmap(i % 10), lw=2, label=f"Group {i + 1}")
                     for i in range(len(parallel_groups))]
    plt.legend(handles=group_handles, bbox_to_anchor=(1.05, 1), loc="upper left")
    plt.title("Combined CR Schedule with Group Labels", fontsize=14, fontweight="bold")
    plt.axis("off")
    plt.savefig(output_path, dpi=300, bbox_inches="tight")
    plt.close()
    print(f"  ✓ Saved: {output_path}")


def visualize_each_step(
    parallel_groups: list[list[tuple[str, str]]],
    qid_to_mux: dict[str, int],
    lattice_pos: dict[str, tuple[float, float]],
    output_dir: Path = SCHEDULE_OUTPUT_DIR
) -> None:
    """Create individual visualization for each parallel group."""
    output_dir.mkdir(parents=True, exist_ok=True)

    for group_idx, group in enumerate(parallel_groups):
        graph = nx.Graph()

        # Add edges for this group
        for control, target in group:
            graph.add_edge(control, target)

        graph.add_nodes_from(lattice_pos.keys())

        plt.figure(figsize=(10, 8))
        nx.draw(graph, pos=lattice_pos, node_color=get_node_colors(graph, qid_to_mux),
                node_size=500, with_labels=True, font_size=8, edge_color="blue", width=2.0)
        plt.title(f"Parallel Group {group_idx + 1} ({len(group)} pairs)",
                  fontsize=14, fontweight="bold")
        plt.axis("off")

        output_file = output_dir / f"schedule_group_{group_idx + 1}.png"
        plt.savefig(output_file, dpi=300, bbox_inches="tight")
        plt.close()

    print(f"  ✓ Saved {len(parallel_groups)} individual group visualizations")


def print_schedule_summary(
    parallel_groups: list[list[tuple[str, str]]],
    metadata: dict,
    filtering_stats: dict
) -> None:
    """Print formatted schedule statistics."""
    print("\n" + "=" * 70)
    print("CR SCHEDULE SUMMARY")
    print("=" * 70)

    print("\nFiltering Statistics:")
    print(f"  Total coupling pairs        : {filtering_stats['all_coupling_pairs']}")
    print(f"  Frequency-filtered pairs    : {filtering_stats['freq_directionality_filtered']}")
    print(f"  Used candidate qubits       : {filtering_stats.get('used_candidate_qubits', False)}")

    print("\nSchedule Statistics:")
    print(f"  Total scheduled pairs       : {metadata['scheduled_pairs']}")
    print(f"  Number of parallel groups   : {metadata['num_groups']}")
    print(f"  Avg pairs per group         : {metadata['scheduled_pairs'] / metadata['num_groups']:.2f}")
    print(f"  Max parallel operations     : {metadata['max_parallel_ops']}")
    print(f"  Coloring strategy           : {metadata['coloring_strategy']}")

    if metadata.get('fast_pairs') is not None:
        print(f"  Fast pairs (intra-MUX)      : {metadata['fast_pairs']}")
        print(f"  Slow pairs (inter-MUX)      : {metadata['slow_pairs']}")

    print("\nGroup Breakdown:")
    for idx, group in enumerate(parallel_groups, 1):
        pairs_str = ", ".join([f"{c}-{t}" for c, t in group])
        print(f"  Group {idx:2d} ({len(group):2d} pairs): {pairs_str}")

    print("\n" + "=" * 70)


# ============================================================================
# Main Execution
# ============================================================================


def main(chip_id: str = DEFAULT_CHIP_ID, username: str = DEFAULT_USERNAME) -> None:
    """Main execution function for CR schedule visualization.

    Args:
        chip_id: Chip ID to use (default: 64Qv3)
        username: Username for chip data access (default: orangekame3)
    """
    print("=" * 70)
    print("CR SCHEDULER VISUALIZER")
    print("=" * 70)
    print(f"\nConfiguration:")
    print(f"  Chip ID           : {chip_id}")
    print(f"  Username          : {username}")
    print(f"  Max parallel ops  : {MAX_PARALLEL_OPS}")
    print(f"  Output directory  : {SCHEDULE_OUTPUT_DIR}/")

    # Initialize database
    initialize()

    # Create scheduler and generate schedule
    print("\nGenerating CR schedule...")
    scheduler = CRScheduler(username=username, chip_id=chip_id)
    result = scheduler.generate(max_parallel_ops=MAX_PARALLEL_OPS)

    # Print summary
    print_schedule_summary(
        result.parallel_groups,
        result.metadata,
        result.filtering_stats
    )

    # Generate visualizations
    print(f"\nGenerating visualizations...")
    lattice_pos = qubit_lattice(TOTAL_QUBITS, LATTICE_DIMENSION)

    visualize_combined_schedule(
        result.parallel_groups,
        result._qid_to_mux,
        lattice_pos
    )

    visualize_each_step(
        result.parallel_groups,
        result._qid_to_mux,
        lattice_pos
    )

    print(f"\n✓ All visualizations saved to {SCHEDULE_OUTPUT_DIR}/")
    print("=" * 70)


if __name__ == "__main__":
    main()
