"""Provenance data models for calibration data lineage tracking.

This module provides data models for tracking the provenance (lineage) of
calibration parameters following W3C PROV-DM standard concepts.

Key concepts:
- Entity: A versioned parameter value at a specific point in time
- Activity: A task execution that generated or consumed entities
- Relations: wasGeneratedBy, used, wasDerivedFrom

Related modules:
- workflow/engine/task/provenance_recorder: Records provenance during execution
- repository/provenance_repository: Repository for provenance queries
"""

from datetime import datetime
from enum import Enum
from typing import ClassVar, Literal

from bunnet import Document
from pydantic import ConfigDict, Field
from pymongo import ASCENDING, DESCENDING, IndexModel
from qdash.common.datetime_utils import now


class ProvenanceRelationType(str, Enum):
    """W3C PROV-DM relation types.

    These relation types follow the W3C PROV-DM standard for representing
    provenance relationships between entities and activities.

    Attributes
    ----------
        GENERATED_BY: Entity was generated by an Activity
        USED: Activity used an Entity as input
        DERIVED_FROM: Entity was derived from another Entity
        ATTRIBUTED_TO: Entity is attributed to an Agent
        INVALIDATED_BY: Entity was invalidated by an Activity

    """

    GENERATED_BY = "wasGeneratedBy"
    USED = "used"
    DERIVED_FROM = "wasDerivedFrom"
    ATTRIBUTED_TO = "wasAttributedTo"
    INVALIDATED_BY = "wasInvalidatedBy"


class ParameterVersionDocument(Document):
    """Versioned parameter entity for provenance tracking.

    Each unique combination of (parameter_name, qid, execution_id, task_id)
    represents a distinct entity in the provenance graph. This allows tracking
    how parameter values evolve across calibration executions.

    Attributes
    ----------
        entity_id: Unique identifier for this parameter version
        parameter_name: Name of the parameter (e.g., "qubit_frequency")
        qid: Qubit or coupling identifier (e.g., "Q0", "Q0-Q1")
        value: The parameter value
        value_type: Type of the value ("float", "int", "complex", etc.)
        unit: Physical unit (e.g., "GHz", "ns", "a.u.")
        error: Measurement error/uncertainty
        version: Version number for this parameter (auto-incremented)
        valid_from: Timestamp when this version became valid
        valid_until: Timestamp when this version was superseded (None if current)
        execution_id: ID of the execution that produced this value
        task_id: ID of the task that produced this value
        project_id: Owning project identifier

    """

    # Unique identifier: "{parameter_name}:{qid}:{execution_id}:{task_id}"
    entity_id: str = Field(..., description="Unique entity identifier")

    # Parameter information
    parameter_name: str = Field(..., description="Name of the parameter")
    qid: str = Field("", description="Qubit or coupling identifier")
    value: float | int | str = Field(..., description="Parameter value")
    value_type: str = Field("float", description="Type of the value")
    unit: str = Field("", description="Physical unit")
    error: float = Field(0.0, description="Measurement error/uncertainty")

    # Version tracking
    version: int = Field(..., description="Version number for this parameter")
    valid_from: datetime = Field(
        default_factory=now,
        description="Timestamp when this version became valid",
    )
    valid_until: datetime | None = Field(
        None,
        description="Timestamp when superseded (None if current)",
    )

    # Traceability
    execution_id: str = Field(..., description="Execution ID that produced this value")
    task_id: str = Field(..., description="Task ID that produced this value")
    task_name: str = Field("", description="Name of the task that produced this value")
    project_id: str = Field(..., description="Owning project identifier")
    chip_id: str = Field("", description="Chip identifier")

    model_config = ConfigDict(
        from_attributes=True,
    )

    class Settings:
        """Settings for the document."""

        name = "parameter_versions"
        indexes: ClassVar = [
            # Primary unique index
            IndexModel(
                [("entity_id", ASCENDING)],
                unique=True,
            ),
            # Query: Get all versions of a parameter for a qubit
            IndexModel(
                [
                    ("project_id", ASCENDING),
                    ("parameter_name", ASCENDING),
                    ("qid", ASCENDING),
                    ("version", DESCENDING),
                ]
            ),
            # Query: Get current (latest) version
            IndexModel(
                [
                    ("project_id", ASCENDING),
                    ("parameter_name", ASCENDING),
                    ("qid", ASCENDING),
                    ("valid_until", ASCENDING),  # None values first
                ]
            ),
            # Query: Get all parameters from an execution
            IndexModel(
                [
                    ("project_id", ASCENDING),
                    ("execution_id", ASCENDING),
                ]
            ),
            # Query: Get parameters by task
            IndexModel(
                [
                    ("project_id", ASCENDING),
                    ("task_id", ASCENDING),
                ]
            ),
            # Query: Get parameters by chip and time range
            IndexModel(
                [
                    ("project_id", ASCENDING),
                    ("chip_id", ASCENDING),
                    ("valid_from", DESCENDING),
                ]
            ),
        ]

    @classmethod
    def generate_entity_id(
        cls,
        parameter_name: str,
        qid: str,
        execution_id: str,
        task_id: str,
    ) -> str:
        """Generate a unique entity ID.

        Parameters
        ----------
        parameter_name : str
            Name of the parameter
        qid : str
            Qubit or coupling identifier
        execution_id : str
            Execution ID
        task_id : str
            Task ID

        Returns
        -------
        str
            Unique entity identifier

        """
        return f"{parameter_name}:{qid}:{execution_id}:{task_id}"

    @classmethod
    def get_next_version(
        cls,
        project_id: str,
        parameter_name: str,
        qid: str,
    ) -> int:
        """Get the next version number for a parameter.

        Parameters
        ----------
        project_id : str
            Project identifier
        parameter_name : str
            Name of the parameter
        qid : str
            Qubit or coupling identifier

        Returns
        -------
        int
            Next version number (1 if no previous versions exist)

        """
        latest = cls.find_one(
            {
                "project_id": project_id,
                "parameter_name": parameter_name,
                "qid": qid,
            },
            sort=[("version", DESCENDING)],
        ).run()
        return (latest.version + 1) if latest else 1

    @classmethod
    def get_current_version(
        cls,
        project_id: str,
        parameter_name: str,
        qid: str,
    ) -> "ParameterVersionDocument | None":
        """Get the current (latest valid) version of a parameter.

        Parameters
        ----------
        project_id : str
            Project identifier
        parameter_name : str
            Name of the parameter
        qid : str
            Qubit or coupling identifier

        Returns
        -------
        ParameterVersionDocument | None
            Current version or None if not found

        """
        result: ParameterVersionDocument | None = cls.find_one(
            {
                "project_id": project_id,
                "parameter_name": parameter_name,
                "qid": qid,
                "valid_until": None,
            }
        ).run()
        return result

    @classmethod
    def invalidate_current(
        cls,
        project_id: str,
        parameter_name: str,
        qid: str,
        invalidated_at: datetime | None = None,
    ) -> None:
        """Invalidate the current version of a parameter.

        Parameters
        ----------
        project_id : str
            Project identifier
        parameter_name : str
            Name of the parameter
        qid : str
            Qubit or coupling identifier
        invalidated_at : datetime | None
            Timestamp of invalidation (default: now)

        """
        current = cls.get_current_version(project_id, parameter_name, qid)
        if current:
            current.valid_until = invalidated_at or now()
            current.save()


class ProvenanceRelationDocument(Document):
    """Provenance relations between entities and activities.

    This document stores the relationships that form the provenance graph.
    Relations follow W3C PROV-DM semantics:
    - wasGeneratedBy: Entity was generated by Activity
    - used: Activity used Entity
    - wasDerivedFrom: Entity was derived from Entity

    Attributes
    ----------
        relation_id: Unique identifier for this relation
        relation_type: Type of provenance relation
        source_type: Type of source ("entity" or "activity")
        source_id: Identifier of the source
        target_type: Type of target ("entity" or "activity")
        target_id: Identifier of the target
        created_at: When this relation was recorded
        confidence: Confidence score (1.0 for explicit, <1.0 for inferred)
        inference_method: Method used for inference (if applicable)
        project_id: Owning project identifier

    """

    # Unique identifier
    relation_id: str = Field(..., description="Unique relation identifier")

    # Relation type
    relation_type: ProvenanceRelationType = Field(..., description="Type of provenance relation")

    # Source (subject of relation)
    source_type: Literal["entity", "activity"] = Field(..., description="Type of source node")
    source_id: str = Field(..., description="Identifier of source node")

    # Target (object of relation)
    target_type: Literal["entity", "activity"] = Field(..., description="Type of target node")
    target_id: str = Field(..., description="Identifier of target node")

    # Metadata
    created_at: datetime = Field(
        default_factory=now,
        description="When this relation was recorded",
    )
    confidence: float = Field(
        1.0,
        description="Confidence score (1.0=explicit, <1.0=inferred)",
    )
    inference_method: str | None = Field(
        None,
        description="Inference method if not explicit",
    )

    # Context
    project_id: str = Field(..., description="Owning project identifier")
    execution_id: str = Field("", description="Related execution ID")

    model_config = ConfigDict(
        from_attributes=True,
    )

    class Settings:
        """Settings for the document."""

        name = "provenance_relations"
        indexes: ClassVar = [
            # Primary unique index
            IndexModel(
                [("relation_id", ASCENDING)],
                unique=True,
            ),
            # Query: Get relations by source (forward traversal)
            IndexModel(
                [
                    ("project_id", ASCENDING),
                    ("source_type", ASCENDING),
                    ("source_id", ASCENDING),
                    ("relation_type", ASCENDING),
                ]
            ),
            # Query: Get relations by target (backward traversal)
            IndexModel(
                [
                    ("project_id", ASCENDING),
                    ("target_type", ASCENDING),
                    ("target_id", ASCENDING),
                    ("relation_type", ASCENDING),
                ]
            ),
            # Query: Get all relations for an execution
            IndexModel(
                [
                    ("project_id", ASCENDING),
                    ("execution_id", ASCENDING),
                ]
            ),
            # Query: Get relations by type
            IndexModel(
                [
                    ("project_id", ASCENDING),
                    ("relation_type", ASCENDING),
                    ("created_at", DESCENDING),
                ]
            ),
        ]

    @classmethod
    def generate_relation_id(
        cls,
        relation_type: ProvenanceRelationType,
        source_id: str,
        target_id: str,
    ) -> str:
        """Generate a unique relation ID.

        Parameters
        ----------
        relation_type : ProvenanceRelationType
            Type of relation
        source_id : str
            Source identifier
        target_id : str
            Target identifier

        Returns
        -------
        str
            Unique relation identifier

        """
        return f"{relation_type.value}:{source_id}:{target_id}"

    @classmethod
    def create_relation(
        cls,
        relation_type: ProvenanceRelationType,
        source_type: Literal["entity", "activity"],
        source_id: str,
        target_type: Literal["entity", "activity"],
        target_id: str,
        project_id: str,
        execution_id: str = "",
        confidence: float = 1.0,
        inference_method: str | None = None,
    ) -> "ProvenanceRelationDocument":
        """Create or update a provenance relation.

        Parameters
        ----------
        relation_type : ProvenanceRelationType
            Type of relation
        source_type : Literal["entity", "activity"]
            Type of source node
        source_id : str
            Source identifier
        target_type : Literal["entity", "activity"]
            Type of target node
        target_id : str
            Target identifier
        project_id : str
            Project identifier
        execution_id : str
            Related execution ID
        confidence : float
            Confidence score
        inference_method : str | None
            Inference method if applicable

        Returns
        -------
        ProvenanceRelationDocument
            Created or existing relation

        """
        relation_id = cls.generate_relation_id(relation_type, source_id, target_id)

        # Check for existing relation
        existing: ProvenanceRelationDocument | None = cls.find_one(
            {"relation_id": relation_id}
        ).run()
        if existing:
            return existing

        # Create new relation
        relation = cls(
            relation_id=relation_id,
            relation_type=relation_type,
            source_type=source_type,
            source_id=source_id,
            target_type=target_type,
            target_id=target_id,
            project_id=project_id,
            execution_id=execution_id,
            confidence=confidence,
            inference_method=inference_method,
        )
        relation.insert()
        return relation


class ActivityDocument(Document):
    """Activity record for provenance tracking.

    Represents a task execution as an activity in the provenance graph.
    This provides a lightweight reference for provenance queries without
    duplicating full task result data.

    Attributes
    ----------
        activity_id: Unique identifier (execution_id:task_id)
        execution_id: Parent execution ID
        task_id: Task identifier
        task_name: Name of the task
        task_type: Type of task (qubit, coupling, global, system)
        qid: Qubit or coupling identifier
        started_at: When the activity started
        ended_at: When the activity ended
        status: Execution status (completed, failed, etc.)
        project_id: Owning project identifier

    """

    activity_id: str = Field(..., description="Unique activity identifier")
    execution_id: str = Field(..., description="Parent execution ID")
    task_id: str = Field(..., description="Task identifier")
    task_name: str = Field(..., description="Name of the task")
    task_type: str = Field("", description="Type of task")
    qid: str = Field("", description="Qubit or coupling identifier")
    started_at: datetime | None = Field(None, description="When the activity started")
    ended_at: datetime | None = Field(None, description="When the activity ended")
    status: str = Field("", description="Execution status")
    project_id: str = Field(..., description="Owning project identifier")
    chip_id: str = Field("", description="Chip identifier")

    model_config = ConfigDict(
        from_attributes=True,
    )

    class Settings:
        """Settings for the document."""

        name = "provenance_activities"
        indexes: ClassVar = [
            IndexModel(
                [("activity_id", ASCENDING)],
                unique=True,
            ),
            IndexModel(
                [
                    ("project_id", ASCENDING),
                    ("execution_id", ASCENDING),
                ]
            ),
            IndexModel(
                [
                    ("project_id", ASCENDING),
                    ("task_name", ASCENDING),
                    ("qid", ASCENDING),
                    ("started_at", DESCENDING),
                ]
            ),
        ]

    @classmethod
    def generate_activity_id(cls, execution_id: str, task_id: str) -> str:
        """Generate a unique activity ID.

        Parameters
        ----------
        execution_id : str
            Execution ID
        task_id : str
            Task ID

        Returns
        -------
        str
            Unique activity identifier

        """
        return f"{execution_id}:{task_id}"
