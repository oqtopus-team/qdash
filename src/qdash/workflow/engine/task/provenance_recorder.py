"""ProvenanceRecorder for tracking calibration data lineage.

This module provides the ProvenanceRecorder class that records provenance
relations during task execution, following W3C PROV-DM concepts.

Key responsibilities:
- Record parameter versions when tasks produce output
- Record wasGeneratedBy relations (entity -> activity)
- Record used relations (activity -> entity)
- Record wasDerivedFrom relations (entity -> entity)
- Create activity records for provenance tracking

Example
-------
    >>> recorder = ProvenanceRecorder()
    >>> recorder.record_from_task(task_result, execution_model)

"""

import logging
import re
from typing import Any, Protocol, runtime_checkable

from bunnet import SortDirection
from qdash.datamodel.execution import ExecutionModel
from qdash.datamodel.task import BaseTaskResultModel, ParameterModel
from qdash.dbmodel.provenance import ProvenanceRelationType
from qdash.repository.provenance import (
    MongoActivityRepository,
    MongoParameterVersionRepository,
    MongoProvenanceRelationRepository,
)

logger = logging.getLogger(__name__)


def resolve_qid(task_qid: str, qid_role: str) -> str:
    """Resolve qid_role to actual qid.

    For 2-qubit tasks, the task_qid is typically in the format "0-1",
    where the first qubit is the control and the second is the target.

    Parameters
    ----------
    task_qid : str
        The task's qid (e.g., "0" for 1-qubit, "0-1" for 2-qubit/coupling)
    qid_role : str
        The role to resolve:
        - "" or "self": Return task_qid as-is
        - "control": Return control qubit's qid
        - "target": Return target qubit's qid
        - "coupling": Return task_qid as-is (coupling ID)

    Returns
    -------
    str
        The resolved qid

    Examples
    --------
    >>> resolve_qid("0", "")
    "0"
    >>> resolve_qid("0-1", "control")
    "0"
    >>> resolve_qid("0-1", "target")
    "1"
    >>> resolve_qid("0-1", "coupling")
    "0-1"

    """
    if qid_role in ("", "self", "coupling"):
        return task_qid

    # Try to parse as 2-qubit format: "0-1"
    match = re.match(r"^(\d+)-(\d+)$", task_qid)
    if match:
        control, target = match.groups()
        if qid_role == "control":
            return control
        elif qid_role == "target":
            return target

    # Fallback: return as-is
    return task_qid


@runtime_checkable
class ParameterVersionRepoProtocol(Protocol):
    """Protocol for parameter version repository."""

    def create_version(
        self,
        *,
        parameter_name: str,
        qid: str,
        value: float | int | str,
        execution_id: str,
        task_id: str,
        project_id: str,
        task_name: str,
        chip_id: str,
        unit: str,
        error: float,
        value_type: str,
    ) -> Any:
        """Create a parameter version."""
        ...

    def get_current(
        self,
        project_id: str,
        parameter_name: str,
        qid: str,
    ) -> Any:
        """Get current version of a parameter."""
        ...


@runtime_checkable
class ProvenanceRelationRepoProtocol(Protocol):
    """Protocol for provenance relation repository."""

    def create_relation(
        self,
        *,
        relation_type: ProvenanceRelationType,
        source_type: str,
        source_id: str,
        target_type: str,
        target_id: str,
        project_id: str,
        execution_id: str,
    ) -> Any:
        """Create a provenance relation."""
        ...


@runtime_checkable
class ActivityRepoProtocol(Protocol):
    """Protocol for activity repository."""

    def create_activity(
        self,
        *,
        execution_id: str,
        task_id: str,
        task_name: str,
        project_id: str,
        task_type: str,
        qid: str,
        chip_id: str,
        started_at: Any,
        ended_at: Any,
        status: str,
    ) -> Any:
        """Create an activity record."""
        ...


class ProvenanceRecorder:
    """Records provenance relations during task execution.

    This class is responsible for tracking the lineage of calibration
    parameters by recording:
    - Parameter versions (entities)
    - Task executions (activities)
    - Provenance relations between them

    The recorder follows W3C PROV-DM semantics:
    - wasGeneratedBy: output parameter was generated by task
    - used: task used input parameter
    - wasDerivedFrom: output parameter derived from input parameters

    Attributes
    ----------
    parameter_version_repo : ParameterVersionRepoProtocol
        Repository for parameter versions
    provenance_relation_repo : ProvenanceRelationRepoProtocol
        Repository for provenance relations
    activity_repo : ActivityRepoProtocol
        Repository for activities

    Example
    -------
        >>> recorder = ProvenanceRecorder()
        >>> recorder.record_from_task(task_result, execution_model)

    """

    def __init__(
        self,
        parameter_version_repo: ParameterVersionRepoProtocol | None = None,
        provenance_relation_repo: ProvenanceRelationRepoProtocol | None = None,
        activity_repo: ActivityRepoProtocol | None = None,
    ) -> None:
        """Initialize ProvenanceRecorder.

        Parameters
        ----------
        parameter_version_repo : ParameterVersionRepoProtocol | None
            Repository for parameter versions (default: MongoParameterVersionRepository)
        provenance_relation_repo : ProvenanceRelationRepoProtocol | None
            Repository for provenance relations (default: MongoProvenanceRelationRepository)
        activity_repo : ActivityRepoProtocol | None
            Repository for activities (default: MongoActivityRepository)

        """
        self.parameter_version_repo = parameter_version_repo or MongoParameterVersionRepository()
        self.provenance_relation_repo = (
            provenance_relation_repo or MongoProvenanceRelationRepository()
        )
        self.activity_repo = activity_repo or MongoActivityRepository()

    def record_from_task(
        self,
        task: BaseTaskResultModel,
        execution_model: ExecutionModel,
    ) -> None:
        """Record provenance from a completed task.

        This method:
        1. Creates an activity record for the task
        2. Records "used" relations for input parameters
        3. Creates parameter versions for output parameters
        4. Records "wasGeneratedBy" relations for outputs
        5. Records "wasDerivedFrom" relations (output <- inputs)

        Parameters
        ----------
        task : BaseTaskResultModel
            The completed task result
        execution_model : ExecutionModel
            The parent execution context

        """
        try:
            project_id = execution_model.project_id or ""
            execution_id = execution_model.execution_id
            chip_id = execution_model.chip_id
            qid = getattr(task, "qid", "")

            # 1. Create activity record
            self.activity_repo.create_activity(
                execution_id=execution_id,
                task_id=task.task_id,
                task_name=task.name,
                project_id=project_id,
                task_type=task.task_type,
                qid=qid,
                chip_id=chip_id,
                started_at=task.start_at,
                ended_at=task.end_at,
                status=task.status,
            )
            activity_id = f"{execution_id}:{task.task_id}"

            # 2. Record "used" relations for input parameters
            input_entity_ids = self._record_input_usage(
                task=task,
                activity_id=activity_id,
                project_id=project_id,
                execution_id=execution_id,
                qid=qid,
            )

            # 3. Create output parameter versions and record relations
            self._record_output_parameters(
                task=task,
                activity_id=activity_id,
                project_id=project_id,
                execution_id=execution_id,
                chip_id=chip_id,
                qid=qid,
                input_entity_ids=input_entity_ids,
            )

            logger.debug(
                f"Recorded provenance for task {task.name} "
                f"(inputs: {len(input_entity_ids)}, outputs: {len(task.output_parameters)})"
            )

        except Exception as e:
            # Log error but don't fail the task
            logger.error(f"Failed to record provenance for task {task.name}: {e}")

    def _record_input_usage(
        self,
        task: BaseTaskResultModel,
        activity_id: str,
        project_id: str,
        execution_id: str,
        qid: str,
    ) -> list[str]:
        """Record "used" relations for input parameters.

        Parameters
        ----------
        task : BaseTaskResultModel
            Task result containing input parameters
        activity_id : str
            Activity identifier
        project_id : str
            Project identifier
        execution_id : str
            Execution ID
        qid : str
            Qubit or coupling identifier

        Returns
        -------
        list[str]
            List of input entity IDs that were used

        """
        input_entity_ids: list[str] = []

        for param_key, param_data in task.input_parameters.items():
            # Determine actual parameter name and resolved qid
            if isinstance(param_data, ParameterModel):
                # Use parameter_name if specified, otherwise use dict key
                param_name = param_data.parameter_name or param_key
                resolved_qid = resolve_qid(qid, param_data.qid_role)
            elif isinstance(param_data, dict):
                param_name = param_data.get("parameter_name") or param_key
                qid_role = param_data.get("qid_role", "")
                resolved_qid = resolve_qid(qid, qid_role)
            else:
                # Fallback: use key as param_name and task qid
                param_name = param_key
                resolved_qid = qid

            # Find the current version of this parameter
            current = self.parameter_version_repo.get_current(
                project_id=project_id,
                parameter_name=param_name,
                qid=resolved_qid,
            )

            if current is not None:
                entity_id = current.entity_id
                input_entity_ids.append(entity_id)

                # Record "used" relation: activity used entity
                self.provenance_relation_repo.create_relation(
                    relation_type=ProvenanceRelationType.USED,
                    source_type="activity",
                    source_id=activity_id,
                    target_type="entity",
                    target_id=entity_id,
                    project_id=project_id,
                    execution_id=execution_id,
                )

        return input_entity_ids

    def _record_output_parameters(
        self,
        task: BaseTaskResultModel,
        activity_id: str,
        project_id: str,
        execution_id: str,
        chip_id: str,
        qid: str,
        input_entity_ids: list[str],
    ) -> None:
        """Create output parameter versions and record relations.

        Parameters
        ----------
        task : BaseTaskResultModel
            Task result containing output parameters
        activity_id : str
            Activity identifier
        project_id : str
            Project identifier
        execution_id : str
            Execution ID
        chip_id : str
            Chip identifier
        qid : str
            Qubit or coupling identifier
        input_entity_ids : list[str]
            List of input entity IDs for derivation relations

        """
        for param_key, param_data in task.output_parameters.items():
            # Extract parameter details and resolve qid
            if isinstance(param_data, ParameterModel):
                param_name = param_data.parameter_name or param_key
                resolved_qid = resolve_qid(qid, param_data.qid_role)
                value = param_data.value
                unit = param_data.unit
                error = param_data.error
                value_type = param_data.value_type
            elif isinstance(param_data, dict):
                param_name = param_data.get("parameter_name") or param_key
                qid_role = param_data.get("qid_role", "")
                resolved_qid = resolve_qid(qid, qid_role)
                value = param_data.get("value", 0)
                unit = param_data.get("unit", "")
                error = param_data.get("error", 0.0)
                value_type = param_data.get("value_type", "float")
            else:
                param_name = param_key
                resolved_qid = qid
                value = param_data
                unit = ""
                error = 0.0
                value_type = "float"

            # Create parameter version
            entity = self.parameter_version_repo.create_version(
                parameter_name=param_name,
                qid=resolved_qid,
                value=value,
                execution_id=execution_id,
                task_id=task.task_id,
                project_id=project_id,
                task_name=task.name,
                chip_id=chip_id,
                unit=unit,
                error=error,
                value_type=value_type,
            )
            entity_id = entity.entity_id

            # Record "wasGeneratedBy" relation: entity was generated by activity
            self.provenance_relation_repo.create_relation(
                relation_type=ProvenanceRelationType.GENERATED_BY,
                source_type="entity",
                source_id=entity_id,
                target_type="activity",
                target_id=activity_id,
                project_id=project_id,
                execution_id=execution_id,
            )

            # Record "wasDerivedFrom" relations: entity derived from input entities
            for input_entity_id in input_entity_ids:
                self.provenance_relation_repo.create_relation(
                    relation_type=ProvenanceRelationType.DERIVED_FROM,
                    source_type="entity",
                    source_id=entity_id,
                    target_type="entity",
                    target_id=input_entity_id,
                    project_id=project_id,
                    execution_id=execution_id,
                )

    def infer_from_existing_history(
        self,
        project_id: str,
        execution_id: str,
    ) -> int:
        """Infer provenance relations from existing task history.

        This method can be used to backfill provenance data for
        executions that were created before provenance tracking was enabled.

        Parameters
        ----------
        project_id : str
            Project identifier
        execution_id : str
            Execution ID to process

        Returns
        -------
        int
            Number of relations created

        """
        # Import here to avoid circular dependency
        from qdash.dbmodel.task_result_history import TaskResultHistoryDocument

        relations_created = 0

        # Get all tasks for this execution, sorted by start time
        tasks = list(
            TaskResultHistoryDocument.find(
                {
                    "project_id": project_id,
                    "execution_id": execution_id,
                }
            )
            .sort([("start_at", SortDirection.ASCENDING)])
            .run()
        )

        if not tasks:
            logger.warning(f"No tasks found for execution {execution_id}")
            return 0

        chip_id = tasks[0].chip_id if tasks else ""

        for task in tasks:
            qid = task.qid
            activity_id = f"{execution_id}:{task.task_id}"

            # Create activity if not exists
            self.activity_repo.create_activity(
                execution_id=execution_id,
                task_id=task.task_id,
                task_name=task.name,
                project_id=project_id,
                task_type=task.task_type,
                qid=qid,
                chip_id=chip_id,
                started_at=task.start_at,
                ended_at=task.end_at,
                status=task.status,
            )

            # Create parameter versions for outputs
            for param_name, param_data in task.output_parameters.items():
                if isinstance(param_data, dict):
                    value = param_data.get("value", 0)
                    unit = param_data.get("unit", "")
                    error = param_data.get("error", 0.0)
                else:
                    value = param_data
                    unit = ""
                    error = 0.0

                entity = self.parameter_version_repo.create_version(
                    parameter_name=param_name,
                    qid=qid,
                    value=value,
                    execution_id=execution_id,
                    task_id=task.task_id,
                    project_id=project_id,
                    task_name=task.name,
                    chip_id=chip_id,
                    unit=unit,
                    error=error,
                    value_type="float",
                )

                # Record wasGeneratedBy relation
                self.provenance_relation_repo.create_relation(
                    relation_type=ProvenanceRelationType.GENERATED_BY,
                    source_type="entity",
                    source_id=entity.entity_id,
                    target_type="activity",
                    target_id=activity_id,
                    project_id=project_id,
                    execution_id=execution_id,
                )
                relations_created += 1

        logger.info(
            f"Inferred {relations_created} provenance relations for execution {execution_id}"
        )
        return relations_created
