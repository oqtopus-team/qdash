/**
 * Generated by orval v7.5.0 üç∫
 * Do not edit manually.
 * QDash Server
 * API for QDash
 * OpenAPI spec version: 0.0.1
 */
import { useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";
import axios from "axios";
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios";
import type {
  ChipResponse,
  ExecutionResponseDetail,
  ExecutionResponseSummary,
  HTTPValidationError,
} from "../../schemas";

/**
 * Fetch all chips.
 * @summary Fetch all chips
 */
export const listChips = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ChipResponse[]>> => {
  return axios.get(`http://localhost:5715/chip`, options);
};

export const getListChipsQueryKey = () => {
  return [`http://localhost:5715/chip`] as const;
};

export const getListChipsQueryOptions = <
  TData = Awaited<ReturnType<typeof listChips>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listChips>>, TError, TData>
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListChipsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listChips>>> = ({
    signal,
  }) => listChips({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listChips>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type ListChipsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listChips>>
>;
export type ListChipsQueryError = AxiosError<unknown>;

export function useListChips<
  TData = Awaited<ReturnType<typeof listChips>>,
  TError = AxiosError<unknown>,
>(options: {
  query: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listChips>>, TError, TData>
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof listChips>>,
        TError,
        Awaited<ReturnType<typeof listChips>>
      >,
      "initialData"
    >;
  axios?: AxiosRequestConfig;
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useListChips<
  TData = Awaited<ReturnType<typeof listChips>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listChips>>, TError, TData>
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof listChips>>,
        TError,
        Awaited<ReturnType<typeof listChips>>
      >,
      "initialData"
    >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useListChips<
  TData = Awaited<ReturnType<typeof listChips>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listChips>>, TError, TData>
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Fetch all chips
 */

export function useListChips<
  TData = Awaited<ReturnType<typeof listChips>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listChips>>, TError, TData>
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getListChipsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Fetch a chip by its ID.
 * @summary Fetch a chip
 */
export const fetchChip = (
  chipId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ChipResponse>> => {
  return axios.get(`http://localhost:5715/chip/${chipId}`, options);
};

export const getFetchChipQueryKey = (chipId: string) => {
  return [`http://localhost:5715/chip/${chipId}`] as const;
};

export const getFetchChipQueryOptions = <
  TData = Awaited<ReturnType<typeof fetchChip>>,
  TError = AxiosError<HTTPValidationError>,
>(
  chipId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof fetchChip>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFetchChipQueryKey(chipId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchChip>>> = ({
    signal,
  }) => fetchChip(chipId, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!chipId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof fetchChip>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData>;
  };
};

export type FetchChipQueryResult = NonNullable<
  Awaited<ReturnType<typeof fetchChip>>
>;
export type FetchChipQueryError = AxiosError<HTTPValidationError>;

export function useFetchChip<
  TData = Awaited<ReturnType<typeof fetchChip>>,
  TError = AxiosError<HTTPValidationError>,
>(
  chipId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof fetchChip>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchChip>>,
          TError,
          Awaited<ReturnType<typeof fetchChip>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useFetchChip<
  TData = Awaited<ReturnType<typeof fetchChip>>,
  TError = AxiosError<HTTPValidationError>,
>(
  chipId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof fetchChip>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchChip>>,
          TError,
          Awaited<ReturnType<typeof fetchChip>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useFetchChip<
  TData = Awaited<ReturnType<typeof fetchChip>>,
  TError = AxiosError<HTTPValidationError>,
>(
  chipId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof fetchChip>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Fetch a chip
 */

export function useFetchChip<
  TData = Awaited<ReturnType<typeof fetchChip>>,
  TError = AxiosError<HTTPValidationError>,
>(
  chipId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof fetchChip>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getFetchChipQueryOptions(chipId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Fetch all executions for a given chip.
 * @summary Fetch executions
 */
export const listExecutionsByChipId = (
  chipId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ExecutionResponseSummary[]>> => {
  return axios.get(`http://localhost:5715/chip/${chipId}/execution`, options);
};

export const getListExecutionsByChipIdQueryKey = (chipId: string) => {
  return [`http://localhost:5715/chip/${chipId}/execution`] as const;
};

export const getListExecutionsByChipIdQueryOptions = <
  TData = Awaited<ReturnType<typeof listExecutionsByChipId>>,
  TError = AxiosError<HTTPValidationError>,
>(
  chipId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listExecutionsByChipId>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getListExecutionsByChipIdQueryKey(chipId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listExecutionsByChipId>>
  > = ({ signal }) =>
    listExecutionsByChipId(chipId, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!chipId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof listExecutionsByChipId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type ListExecutionsByChipIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof listExecutionsByChipId>>
>;
export type ListExecutionsByChipIdQueryError = AxiosError<HTTPValidationError>;

export function useListExecutionsByChipId<
  TData = Awaited<ReturnType<typeof listExecutionsByChipId>>,
  TError = AxiosError<HTTPValidationError>,
>(
  chipId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listExecutionsByChipId>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listExecutionsByChipId>>,
          TError,
          Awaited<ReturnType<typeof listExecutionsByChipId>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useListExecutionsByChipId<
  TData = Awaited<ReturnType<typeof listExecutionsByChipId>>,
  TError = AxiosError<HTTPValidationError>,
>(
  chipId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listExecutionsByChipId>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listExecutionsByChipId>>,
          TError,
          Awaited<ReturnType<typeof listExecutionsByChipId>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useListExecutionsByChipId<
  TData = Awaited<ReturnType<typeof listExecutionsByChipId>>,
  TError = AxiosError<HTTPValidationError>,
>(
  chipId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listExecutionsByChipId>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Fetch executions
 */

export function useListExecutionsByChipId<
  TData = Awaited<ReturnType<typeof listExecutionsByChipId>>,
  TError = AxiosError<HTTPValidationError>,
>(
  chipId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listExecutionsByChipId>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getListExecutionsByChipIdQueryOptions(chipId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Return the execution detail by its ID.
 * @summary Fetch an execution by its ID
 */
export const fetchExecutionByChipId = (
  chipId: string,
  executionId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ExecutionResponseDetail>> => {
  return axios.get(
    `http://localhost:5715/chip/${chipId}/execution/${executionId}`,
    options,
  );
};

export const getFetchExecutionByChipIdQueryKey = (
  chipId: string,
  executionId: string,
) => {
  return [
    `http://localhost:5715/chip/${chipId}/execution/${executionId}`,
  ] as const;
};

export const getFetchExecutionByChipIdQueryOptions = <
  TData = Awaited<ReturnType<typeof fetchExecutionByChipId>>,
  TError = AxiosError<HTTPValidationError>,
>(
  chipId: string,
  executionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchExecutionByChipId>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getFetchExecutionByChipIdQueryKey(chipId, executionId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof fetchExecutionByChipId>>
  > = ({ signal }) =>
    fetchExecutionByChipId(chipId, executionId, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!(chipId && executionId),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof fetchExecutionByChipId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type FetchExecutionByChipIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof fetchExecutionByChipId>>
>;
export type FetchExecutionByChipIdQueryError = AxiosError<HTTPValidationError>;

export function useFetchExecutionByChipId<
  TData = Awaited<ReturnType<typeof fetchExecutionByChipId>>,
  TError = AxiosError<HTTPValidationError>,
>(
  chipId: string,
  executionId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchExecutionByChipId>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchExecutionByChipId>>,
          TError,
          Awaited<ReturnType<typeof fetchExecutionByChipId>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useFetchExecutionByChipId<
  TData = Awaited<ReturnType<typeof fetchExecutionByChipId>>,
  TError = AxiosError<HTTPValidationError>,
>(
  chipId: string,
  executionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchExecutionByChipId>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchExecutionByChipId>>,
          TError,
          Awaited<ReturnType<typeof fetchExecutionByChipId>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useFetchExecutionByChipId<
  TData = Awaited<ReturnType<typeof fetchExecutionByChipId>>,
  TError = AxiosError<HTTPValidationError>,
>(
  chipId: string,
  executionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchExecutionByChipId>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Fetch an execution by its ID
 */

export function useFetchExecutionByChipId<
  TData = Awaited<ReturnType<typeof fetchExecutionByChipId>>,
  TError = AxiosError<HTTPValidationError>,
>(
  chipId: string,
  executionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchExecutionByChipId>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getFetchExecutionByChipIdQueryOptions(
    chipId,
    executionId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
