/**
 * Generated by orval v7.14.0 üç∫
 * Do not edit manually.
 * QDash API
 * API for QDash
 * OpenAPI spec version: 0.0.1
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  BodyDownloadFiguresAsZip,
  CommentCreate,
  CommentResponse,
  GetCouplingTaskHistoryParams,
  GetHistoricalCouplingTaskResultsParams,
  GetHistoricalQubitTaskResultsParams,
  GetLatestCouplingTaskResultsParams,
  GetLatestQubitTaskResultsParams,
  GetQubitTaskHistoryParams,
  GetTimeseriesTaskResultsParams,
  HTTPValidationError,
  LatestTaskResultResponse,
  ListAllCommentsParams,
  ListCommentsResponse,
  SuccessResponse,
  TaskHistoryResponse,
  TimeSeriesData,
} from "../../schemas";

import { customInstance } from "../../lib/custom-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Get the latest qubit task results for all qubits on a chip.

Retrieves the most recent task result for each qubit on the specified chip.
Results include fidelity threshold status based on x90 gate fidelity.

Parameters
----------
chip_id : str
    ID of the chip to fetch results for
task : str
    Name of the task to fetch results for
ctx : ProjectContext
    Project context with user and project information

Returns
-------
LatestTaskResultResponse
    Task results for all qubits, keyed by qubit ID

Raises
------
ValueError
    If the chip is not found for the current project
 * @summary Get latest qubit task results
 */
export const getLatestQubitTaskResults = (
  params: GetLatestQubitTaskResultsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<LatestTaskResultResponse>(
    { url: `/task-results/qubits/latest`, method: "GET", params, signal },
    options,
  );
};

export const getGetLatestQubitTaskResultsQueryKey = (
  params?: GetLatestQubitTaskResultsParams,
) => {
  return [`/task-results/qubits/latest`, ...(params ? [params] : [])] as const;
};

export const getGetLatestQubitTaskResultsQueryOptions = <
  TData = Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetLatestQubitTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetLatestQubitTaskResultsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLatestQubitTaskResults>>
  > = ({ signal }) => getLatestQubitTaskResults(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetLatestQubitTaskResultsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLatestQubitTaskResults>>
>;
export type GetLatestQubitTaskResultsQueryError = HTTPValidationError;

export function useGetLatestQubitTaskResults<
  TData = Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetLatestQubitTaskResultsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getLatestQubitTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetLatestQubitTaskResults<
  TData = Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetLatestQubitTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getLatestQubitTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLatestQubitTaskResults<
  TData = Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetLatestQubitTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get latest qubit task results
 */

export function useGetLatestQubitTaskResults<
  TData = Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetLatestQubitTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetLatestQubitTaskResultsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get historical qubit task results for a specific date.

Retrieves task results from a specific historical date using chip history
snapshots. Results are filtered to tasks executed within the specified
day in JST timezone.

Parameters
----------
chip_id : str
    ID of the chip to fetch results for
task : str
    Name of the task to fetch results for
date : str
    Date in YYYYMMDD format (JST timezone)
ctx : ProjectContext
    Project context with user and project information

Returns
-------
LatestTaskResultResponse
    Historical task results for all qubits, keyed by qubit ID

Raises
------
ValueError
    If the chip history is not found for the specified date
 * @summary Get historical qubit task results
 */
export const getHistoricalQubitTaskResults = (
  params: GetHistoricalQubitTaskResultsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<LatestTaskResultResponse>(
    { url: `/task-results/qubits/history`, method: "GET", params, signal },
    options,
  );
};

export const getGetHistoricalQubitTaskResultsQueryKey = (
  params?: GetHistoricalQubitTaskResultsParams,
) => {
  return [`/task-results/qubits/history`, ...(params ? [params] : [])] as const;
};

export const getGetHistoricalQubitTaskResultsQueryOptions = <
  TData = Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetHistoricalQubitTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetHistoricalQubitTaskResultsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>
  > = ({ signal }) =>
    getHistoricalQubitTaskResults(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetHistoricalQubitTaskResultsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>
>;
export type GetHistoricalQubitTaskResultsQueryError = HTTPValidationError;

export function useGetHistoricalQubitTaskResults<
  TData = Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetHistoricalQubitTaskResultsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetHistoricalQubitTaskResults<
  TData = Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetHistoricalQubitTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetHistoricalQubitTaskResults<
  TData = Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetHistoricalQubitTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get historical qubit task results
 */

export function useGetHistoricalQubitTaskResults<
  TData = Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetHistoricalQubitTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetHistoricalQubitTaskResultsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get complete task history for a specific qubit.

Retrieves all historical task results for a specific qubit, sorted by
end time in descending order. Useful for tracking calibration trends
over time.

Parameters
----------
qid : str
    Qubit ID to fetch history for
chip_id : str
    ID of the chip containing the qubit
task : str
    Name of the task to fetch history for
ctx : ProjectContext
    Project context with user and project information

Returns
-------
TaskHistoryResponse
    All historical task results, keyed by task_id

Raises
------
ValueError
    If the chip is not found for the current project
 * @summary Get qubit task history
 */
export const getQubitTaskHistory = (
  qid: string,
  params: GetQubitTaskHistoryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TaskHistoryResponse>(
    {
      url: `/task-results/qubits/${qid}/history`,
      method: "GET",
      params,
      signal,
    },
    options,
  );
};

export const getGetQubitTaskHistoryQueryKey = (
  qid?: string,
  params?: GetQubitTaskHistoryParams,
) => {
  return [
    `/task-results/qubits/${qid}/history`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetQubitTaskHistoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getQubitTaskHistory>>,
  TError = HTTPValidationError,
>(
  qid: string,
  params: GetQubitTaskHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQubitTaskHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetQubitTaskHistoryQueryKey(qid, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getQubitTaskHistory>>
  > = ({ signal }) => getQubitTaskHistory(qid, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!qid,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getQubitTaskHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetQubitTaskHistoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getQubitTaskHistory>>
>;
export type GetQubitTaskHistoryQueryError = HTTPValidationError;

export function useGetQubitTaskHistory<
  TData = Awaited<ReturnType<typeof getQubitTaskHistory>>,
  TError = HTTPValidationError,
>(
  qid: string,
  params: GetQubitTaskHistoryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQubitTaskHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQubitTaskHistory>>,
          TError,
          Awaited<ReturnType<typeof getQubitTaskHistory>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetQubitTaskHistory<
  TData = Awaited<ReturnType<typeof getQubitTaskHistory>>,
  TError = HTTPValidationError,
>(
  qid: string,
  params: GetQubitTaskHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQubitTaskHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQubitTaskHistory>>,
          TError,
          Awaited<ReturnType<typeof getQubitTaskHistory>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetQubitTaskHistory<
  TData = Awaited<ReturnType<typeof getQubitTaskHistory>>,
  TError = HTTPValidationError,
>(
  qid: string,
  params: GetQubitTaskHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQubitTaskHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get qubit task history
 */

export function useGetQubitTaskHistory<
  TData = Awaited<ReturnType<typeof getQubitTaskHistory>>,
  TError = HTTPValidationError,
>(
  qid: string,
  params: GetQubitTaskHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQubitTaskHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetQubitTaskHistoryQueryOptions(qid, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get the latest coupling task results for all couplings on a chip.

Retrieves the most recent task result for each coupling (qubit pair) on
the specified chip. Results include fidelity threshold status based on
Bell state fidelity.

Parameters
----------
chip_id : str
    ID of the chip to fetch results for
task : str
    Name of the task to fetch results for
ctx : ProjectContext
    Project context with user and project information

Returns
-------
LatestTaskResultResponse
    Task results for all couplings, keyed by coupling ID (e.g., "0-1")

Raises
------
ValueError
    If the chip is not found for the current project
 * @summary Get latest coupling task results
 */
export const getLatestCouplingTaskResults = (
  params: GetLatestCouplingTaskResultsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<LatestTaskResultResponse>(
    { url: `/task-results/couplings/latest`, method: "GET", params, signal },
    options,
  );
};

export const getGetLatestCouplingTaskResultsQueryKey = (
  params?: GetLatestCouplingTaskResultsParams,
) => {
  return [
    `/task-results/couplings/latest`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetLatestCouplingTaskResultsQueryOptions = <
  TData = Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetLatestCouplingTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetLatestCouplingTaskResultsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLatestCouplingTaskResults>>
  > = ({ signal }) =>
    getLatestCouplingTaskResults(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetLatestCouplingTaskResultsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLatestCouplingTaskResults>>
>;
export type GetLatestCouplingTaskResultsQueryError = HTTPValidationError;

export function useGetLatestCouplingTaskResults<
  TData = Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetLatestCouplingTaskResultsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getLatestCouplingTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetLatestCouplingTaskResults<
  TData = Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetLatestCouplingTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getLatestCouplingTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLatestCouplingTaskResults<
  TData = Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetLatestCouplingTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get latest coupling task results
 */

export function useGetLatestCouplingTaskResults<
  TData = Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetLatestCouplingTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetLatestCouplingTaskResultsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get historical coupling task results for a specific date.

Retrieves task results from a specific historical date using chip history
snapshots. Results are filtered to tasks executed within the specified
day in JST timezone.

Parameters
----------
chip_id : str
    ID of the chip to fetch results for
task : str
    Name of the task to fetch results for
date : str
    Date in YYYYMMDD format (JST timezone)
ctx : ProjectContext
    Project context with user and project information

Returns
-------
LatestTaskResultResponse
    Historical task results for all couplings, keyed by coupling ID

Raises
------
ValueError
    If the chip history is not found for the specified date
 * @summary Get historical coupling task results
 */
export const getHistoricalCouplingTaskResults = (
  params: GetHistoricalCouplingTaskResultsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<LatestTaskResultResponse>(
    { url: `/task-results/couplings/history`, method: "GET", params, signal },
    options,
  );
};

export const getGetHistoricalCouplingTaskResultsQueryKey = (
  params?: GetHistoricalCouplingTaskResultsParams,
) => {
  return [
    `/task-results/couplings/history`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetHistoricalCouplingTaskResultsQueryOptions = <
  TData = Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetHistoricalCouplingTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetHistoricalCouplingTaskResultsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>
  > = ({ signal }) =>
    getHistoricalCouplingTaskResults(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetHistoricalCouplingTaskResultsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>
>;
export type GetHistoricalCouplingTaskResultsQueryError = HTTPValidationError;

export function useGetHistoricalCouplingTaskResults<
  TData = Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetHistoricalCouplingTaskResultsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetHistoricalCouplingTaskResults<
  TData = Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetHistoricalCouplingTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetHistoricalCouplingTaskResults<
  TData = Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetHistoricalCouplingTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get historical coupling task results
 */

export function useGetHistoricalCouplingTaskResults<
  TData = Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetHistoricalCouplingTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetHistoricalCouplingTaskResultsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get complete task history for a specific coupling.

Retrieves all historical task results for a specific coupling (qubit pair),
sorted by end time in descending order. Useful for tracking two-qubit
calibration trends over time.

Parameters
----------
coupling_id : str
    Coupling ID to fetch history for (e.g., "0-1")
chip_id : str
    ID of the chip containing the coupling
task : str
    Name of the task to fetch history for
ctx : ProjectContext
    Project context with user and project information

Returns
-------
TaskHistoryResponse
    All historical task results, keyed by task_id

Raises
------
ValueError
    If the chip is not found for the current project
 * @summary Get coupling task history
 */
export const getCouplingTaskHistory = (
  couplingId: string,
  params: GetCouplingTaskHistoryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TaskHistoryResponse>(
    {
      url: `/task-results/couplings/${couplingId}/history`,
      method: "GET",
      params,
      signal,
    },
    options,
  );
};

export const getGetCouplingTaskHistoryQueryKey = (
  couplingId?: string,
  params?: GetCouplingTaskHistoryParams,
) => {
  return [
    `/task-results/couplings/${couplingId}/history`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetCouplingTaskHistoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getCouplingTaskHistory>>,
  TError = HTTPValidationError,
>(
  couplingId: string,
  params: GetCouplingTaskHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCouplingTaskHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetCouplingTaskHistoryQueryKey(couplingId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getCouplingTaskHistory>>
  > = ({ signal }) =>
    getCouplingTaskHistory(couplingId, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!couplingId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getCouplingTaskHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetCouplingTaskHistoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCouplingTaskHistory>>
>;
export type GetCouplingTaskHistoryQueryError = HTTPValidationError;

export function useGetCouplingTaskHistory<
  TData = Awaited<ReturnType<typeof getCouplingTaskHistory>>,
  TError = HTTPValidationError,
>(
  couplingId: string,
  params: GetCouplingTaskHistoryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCouplingTaskHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCouplingTaskHistory>>,
          TError,
          Awaited<ReturnType<typeof getCouplingTaskHistory>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetCouplingTaskHistory<
  TData = Awaited<ReturnType<typeof getCouplingTaskHistory>>,
  TError = HTTPValidationError,
>(
  couplingId: string,
  params: GetCouplingTaskHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCouplingTaskHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCouplingTaskHistory>>,
          TError,
          Awaited<ReturnType<typeof getCouplingTaskHistory>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetCouplingTaskHistory<
  TData = Awaited<ReturnType<typeof getCouplingTaskHistory>>,
  TError = HTTPValidationError,
>(
  couplingId: string,
  params: GetCouplingTaskHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCouplingTaskHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get coupling task history
 */

export function useGetCouplingTaskHistory<
  TData = Awaited<ReturnType<typeof getCouplingTaskHistory>>,
  TError = HTTPValidationError,
>(
  couplingId: string,
  params: GetCouplingTaskHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCouplingTaskHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetCouplingTaskHistoryQueryOptions(
    couplingId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get timeseries task results filtered by tag and parameter.

Retrieves time series data for calibration parameters, optionally filtered
to a specific qubit. Useful for plotting parameter trends over time.

Parameters
----------
chip_id : str
    ID of the chip to fetch results for
tag : str
    Tag to filter tasks by (e.g., calibration category)
parameter : str
    Name of the output parameter to retrieve
start_at : str
    Start time in ISO format for the time range
end_at : str
    End time in ISO format for the time range
ctx : ProjectContext
    Project context with user and project information
qid : str | None
    Optional qubit ID to filter results to a specific qubit

Returns
-------
TimeSeriesData
    Time series data keyed by qubit ID, each containing a list of
    parameter values with timestamps
 * @summary Get timeseries task results by tag and parameter
 */
export const getTimeseriesTaskResults = (
  params: GetTimeseriesTaskResultsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TimeSeriesData>(
    { url: `/task-results/timeseries`, method: "GET", params, signal },
    options,
  );
};

export const getGetTimeseriesTaskResultsQueryKey = (
  params?: GetTimeseriesTaskResultsParams,
) => {
  return [`/task-results/timeseries`, ...(params ? [params] : [])] as const;
};

export const getGetTimeseriesTaskResultsQueryOptions = <
  TData = Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetTimeseriesTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTimeseriesTaskResultsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTimeseriesTaskResults>>
  > = ({ signal }) => getTimeseriesTaskResults(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetTimeseriesTaskResultsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTimeseriesTaskResults>>
>;
export type GetTimeseriesTaskResultsQueryError = HTTPValidationError;

export function useGetTimeseriesTaskResults<
  TData = Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetTimeseriesTaskResultsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getTimeseriesTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetTimeseriesTaskResults<
  TData = Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetTimeseriesTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getTimeseriesTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetTimeseriesTaskResults<
  TData = Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetTimeseriesTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get timeseries task results by tag and parameter
 */

export function useGetTimeseriesTaskResults<
  TData = Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetTimeseriesTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetTimeseriesTaskResultsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Download multiple calibration figures as a ZIP file.

Creates a ZIP archive containing all requested figure files and returns it
as a streaming response.

Parameters
----------
paths : list[str]
    List of absolute file paths to the calibration figures
filename : str
    Filename for the ZIP archive (default: "figures.zip")

Returns
-------
StreamingResponse
    ZIP archive containing all requested files

Raises
------
HTTPException
    400 if no paths are provided or if any path does not exist
 * @summary Download multiple figures as a ZIP file
 */
export const downloadFiguresAsZip = (
  bodyDownloadFiguresAsZip: BodyDownloadFiguresAsZip,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>(
    {
      url: `/task-results/figures/download`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: bodyDownloadFiguresAsZip,
      signal,
    },
    options,
  );
};

export const getDownloadFiguresAsZipMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof downloadFiguresAsZip>>,
    TError,
    { data: BodyDownloadFiguresAsZip },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof downloadFiguresAsZip>>,
  TError,
  { data: BodyDownloadFiguresAsZip },
  TContext
> => {
  const mutationKey = ["downloadFiguresAsZip"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof downloadFiguresAsZip>>,
    { data: BodyDownloadFiguresAsZip }
  > = (props) => {
    const { data } = props ?? {};

    return downloadFiguresAsZip(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DownloadFiguresAsZipMutationResult = NonNullable<
  Awaited<ReturnType<typeof downloadFiguresAsZip>>
>;
export type DownloadFiguresAsZipMutationBody = BodyDownloadFiguresAsZip;
export type DownloadFiguresAsZipMutationError = HTTPValidationError;

/**
 * @summary Download multiple figures as a ZIP file
 */
export const useDownloadFiguresAsZip = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof downloadFiguresAsZip>>,
      TError,
      { data: BodyDownloadFiguresAsZip },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof downloadFiguresAsZip>>,
  TError,
  { data: BodyDownloadFiguresAsZip },
  TContext
> => {
  const mutationOptions = getDownloadFiguresAsZipMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * List all root comments across the project, with reply counts.
 * @summary List all comments across tasks
 */
export const listAllComments = (
  params?: ListAllCommentsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ListCommentsResponse>(
    { url: `/task-results/comments`, method: "GET", params, signal },
    options,
  );
};

export const getListAllCommentsQueryKey = (params?: ListAllCommentsParams) => {
  return [`/task-results/comments`, ...(params ? [params] : [])] as const;
};

export const getListAllCommentsQueryOptions = <
  TData = Awaited<ReturnType<typeof listAllComments>>,
  TError = HTTPValidationError,
>(
  params?: ListAllCommentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAllComments>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListAllCommentsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listAllComments>>> = ({
    signal,
  }) => listAllComments(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listAllComments>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type ListAllCommentsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listAllComments>>
>;
export type ListAllCommentsQueryError = HTTPValidationError;

export function useListAllComments<
  TData = Awaited<ReturnType<typeof listAllComments>>,
  TError = HTTPValidationError,
>(
  params: undefined | ListAllCommentsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAllComments>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAllComments>>,
          TError,
          Awaited<ReturnType<typeof listAllComments>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useListAllComments<
  TData = Awaited<ReturnType<typeof listAllComments>>,
  TError = HTTPValidationError,
>(
  params?: ListAllCommentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAllComments>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAllComments>>,
          TError,
          Awaited<ReturnType<typeof listAllComments>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useListAllComments<
  TData = Awaited<ReturnType<typeof listAllComments>>,
  TError = HTTPValidationError,
>(
  params?: ListAllCommentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAllComments>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary List all comments across tasks
 */

export function useListAllComments<
  TData = Awaited<ReturnType<typeof listAllComments>>,
  TError = HTTPValidationError,
>(
  params?: ListAllCommentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAllComments>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getListAllCommentsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get a single root comment by its ID, including reply count.
 * @summary Get a single comment by ID
 */
export const getComment = (
  commentId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CommentResponse>(
    { url: `/task-results/comments/${commentId}`, method: "GET", signal },
    options,
  );
};

export const getGetCommentQueryKey = (commentId?: string) => {
  return [`/task-results/comments/${commentId}`] as const;
};

export const getGetCommentQueryOptions = <
  TData = Awaited<ReturnType<typeof getComment>>,
  TError = HTTPValidationError,
>(
  commentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getComment>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCommentQueryKey(commentId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getComment>>> = ({
    signal,
  }) => getComment(commentId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!commentId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getComment>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetCommentQueryResult = NonNullable<
  Awaited<ReturnType<typeof getComment>>
>;
export type GetCommentQueryError = HTTPValidationError;

export function useGetComment<
  TData = Awaited<ReturnType<typeof getComment>>,
  TError = HTTPValidationError,
>(
  commentId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getComment>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getComment>>,
          TError,
          Awaited<ReturnType<typeof getComment>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetComment<
  TData = Awaited<ReturnType<typeof getComment>>,
  TError = HTTPValidationError,
>(
  commentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getComment>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getComment>>,
          TError,
          Awaited<ReturnType<typeof getComment>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetComment<
  TData = Awaited<ReturnType<typeof getComment>>,
  TError = HTTPValidationError,
>(
  commentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getComment>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get a single comment by ID
 */

export function useGetComment<
  TData = Awaited<ReturnType<typeof getComment>>,
  TError = HTTPValidationError,
>(
  commentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getComment>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetCommentQueryOptions(commentId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * List all replies to a specific comment, sorted by creation time ascending.
 * @summary List replies for a comment
 */
export const getCommentReplies = (
  commentId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CommentResponse[]>(
    {
      url: `/task-results/comments/${commentId}/replies`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetCommentRepliesQueryKey = (commentId?: string) => {
  return [`/task-results/comments/${commentId}/replies`] as const;
};

export const getGetCommentRepliesQueryOptions = <
  TData = Awaited<ReturnType<typeof getCommentReplies>>,
  TError = HTTPValidationError,
>(
  commentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCommentReplies>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetCommentRepliesQueryKey(commentId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getCommentReplies>>
  > = ({ signal }) => getCommentReplies(commentId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!commentId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getCommentReplies>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetCommentRepliesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCommentReplies>>
>;
export type GetCommentRepliesQueryError = HTTPValidationError;

export function useGetCommentReplies<
  TData = Awaited<ReturnType<typeof getCommentReplies>>,
  TError = HTTPValidationError,
>(
  commentId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCommentReplies>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCommentReplies>>,
          TError,
          Awaited<ReturnType<typeof getCommentReplies>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetCommentReplies<
  TData = Awaited<ReturnType<typeof getCommentReplies>>,
  TError = HTTPValidationError,
>(
  commentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCommentReplies>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCommentReplies>>,
          TError,
          Awaited<ReturnType<typeof getCommentReplies>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetCommentReplies<
  TData = Awaited<ReturnType<typeof getCommentReplies>>,
  TError = HTTPValidationError,
>(
  commentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCommentReplies>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary List replies for a comment
 */

export function useGetCommentReplies<
  TData = Awaited<ReturnType<typeof getCommentReplies>>,
  TError = HTTPValidationError,
>(
  commentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCommentReplies>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetCommentRepliesQueryOptions(commentId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * List all comments for a task result, sorted by creation time ascending.
 * @summary List comments for a task result
 */
export const getTaskResultComments = (
  taskId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CommentResponse[]>(
    { url: `/task-results/${taskId}/comments`, method: "GET", signal },
    options,
  );
};

export const getGetTaskResultCommentsQueryKey = (taskId?: string) => {
  return [`/task-results/${taskId}/comments`] as const;
};

export const getGetTaskResultCommentsQueryOptions = <
  TData = Awaited<ReturnType<typeof getTaskResultComments>>,
  TError = HTTPValidationError,
>(
  taskId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTaskResultComments>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTaskResultCommentsQueryKey(taskId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTaskResultComments>>
  > = ({ signal }) => getTaskResultComments(taskId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!taskId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTaskResultComments>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetTaskResultCommentsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTaskResultComments>>
>;
export type GetTaskResultCommentsQueryError = HTTPValidationError;

export function useGetTaskResultComments<
  TData = Awaited<ReturnType<typeof getTaskResultComments>>,
  TError = HTTPValidationError,
>(
  taskId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTaskResultComments>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTaskResultComments>>,
          TError,
          Awaited<ReturnType<typeof getTaskResultComments>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetTaskResultComments<
  TData = Awaited<ReturnType<typeof getTaskResultComments>>,
  TError = HTTPValidationError,
>(
  taskId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTaskResultComments>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTaskResultComments>>,
          TError,
          Awaited<ReturnType<typeof getTaskResultComments>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetTaskResultComments<
  TData = Awaited<ReturnType<typeof getTaskResultComments>>,
  TError = HTTPValidationError,
>(
  taskId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTaskResultComments>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary List comments for a task result
 */

export function useGetTaskResultComments<
  TData = Awaited<ReturnType<typeof getTaskResultComments>>,
  TError = HTTPValidationError,
>(
  taskId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTaskResultComments>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetTaskResultCommentsQueryOptions(taskId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new comment on a task result.
 * @summary Create a comment on a task result
 */
export const createTaskResultComment = (
  taskId: string,
  commentCreate: CommentCreate,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CommentResponse>(
    {
      url: `/task-results/${taskId}/comments`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: commentCreate,
      signal,
    },
    options,
  );
};

export const getCreateTaskResultCommentMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTaskResultComment>>,
    TError,
    { taskId: string; data: CommentCreate },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createTaskResultComment>>,
  TError,
  { taskId: string; data: CommentCreate },
  TContext
> => {
  const mutationKey = ["createTaskResultComment"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTaskResultComment>>,
    { taskId: string; data: CommentCreate }
  > = (props) => {
    const { taskId, data } = props ?? {};

    return createTaskResultComment(taskId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateTaskResultCommentMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTaskResultComment>>
>;
export type CreateTaskResultCommentMutationBody = CommentCreate;
export type CreateTaskResultCommentMutationError = HTTPValidationError;

/**
 * @summary Create a comment on a task result
 */
export const useCreateTaskResultComment = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createTaskResultComment>>,
      TError,
      { taskId: string; data: CommentCreate },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createTaskResultComment>>,
  TError,
  { taskId: string; data: CommentCreate },
  TContext
> => {
  const mutationOptions = getCreateTaskResultCommentMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Delete a comment. Only the author can delete their own comment.
 * @summary Delete a comment on a task result
 */
export const deleteTaskResultComment = (
  taskId: string,
  commentId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<SuccessResponse>(
    { url: `/task-results/${taskId}/comments/${commentId}`, method: "DELETE" },
    options,
  );
};

export const getDeleteTaskResultCommentMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteTaskResultComment>>,
    TError,
    { taskId: string; commentId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteTaskResultComment>>,
  TError,
  { taskId: string; commentId: string },
  TContext
> => {
  const mutationKey = ["deleteTaskResultComment"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteTaskResultComment>>,
    { taskId: string; commentId: string }
  > = (props) => {
    const { taskId, commentId } = props ?? {};

    return deleteTaskResultComment(taskId, commentId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteTaskResultCommentMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteTaskResultComment>>
>;

export type DeleteTaskResultCommentMutationError = HTTPValidationError;

/**
 * @summary Delete a comment on a task result
 */
export const useDeleteTaskResultComment = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteTaskResultComment>>,
      TError,
      { taskId: string; commentId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteTaskResultComment>>,
  TError,
  { taskId: string; commentId: string },
  TContext
> => {
  const mutationOptions = getDeleteTaskResultCommentMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Close a comment thread. Only the author or project owner can close.
 * @summary Close a comment thread
 */
export const closeCommentThread = (
  commentId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<SuccessResponse>(
    { url: `/task-results/comments/${commentId}/close`, method: "PATCH" },
    options,
  );
};

export const getCloseCommentThreadMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof closeCommentThread>>,
    TError,
    { commentId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof closeCommentThread>>,
  TError,
  { commentId: string },
  TContext
> => {
  const mutationKey = ["closeCommentThread"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof closeCommentThread>>,
    { commentId: string }
  > = (props) => {
    const { commentId } = props ?? {};

    return closeCommentThread(commentId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CloseCommentThreadMutationResult = NonNullable<
  Awaited<ReturnType<typeof closeCommentThread>>
>;

export type CloseCommentThreadMutationError = HTTPValidationError;

/**
 * @summary Close a comment thread
 */
export const useCloseCommentThread = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof closeCommentThread>>,
      TError,
      { commentId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof closeCommentThread>>,
  TError,
  { commentId: string },
  TContext
> => {
  const mutationOptions = getCloseCommentThreadMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Reopen a closed comment thread. Only the author or project owner can reopen.
 * @summary Reopen a comment thread
 */
export const reopenCommentThread = (
  commentId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<SuccessResponse>(
    { url: `/task-results/comments/${commentId}/reopen`, method: "PATCH" },
    options,
  );
};

export const getReopenCommentThreadMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reopenCommentThread>>,
    TError,
    { commentId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof reopenCommentThread>>,
  TError,
  { commentId: string },
  TContext
> => {
  const mutationKey = ["reopenCommentThread"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reopenCommentThread>>,
    { commentId: string }
  > = (props) => {
    const { commentId } = props ?? {};

    return reopenCommentThread(commentId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReopenCommentThreadMutationResult = NonNullable<
  Awaited<ReturnType<typeof reopenCommentThread>>
>;

export type ReopenCommentThreadMutationError = HTTPValidationError;

/**
 * @summary Reopen a comment thread
 */
export const useReopenCommentThread = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof reopenCommentThread>>,
      TError,
      { commentId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof reopenCommentThread>>,
  TError,
  { commentId: string },
  TContext
> => {
  const mutationOptions = getReopenCommentThreadMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
