/**
 * Generated by orval v7.14.0 üç∫
 * Do not edit manually.
 * QDash API
 * API for QDash
 * OpenAPI spec version: 0.0.1
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  BodyDownloadFiguresAsZip,
  GetCouplingTaskHistoryParams,
  GetHistoricalCouplingTaskResultsParams,
  GetHistoricalQubitTaskResultsParams,
  GetLatestCouplingTaskResultsParams,
  GetLatestQubitTaskResultsParams,
  GetQubitTaskHistoryParams,
  GetTimeseriesTaskResultsParams,
  HTTPValidationError,
  LatestTaskResultResponse,
  TaskHistoryResponse,
  TimeSeriesData,
} from "../../schemas";

import { customInstance } from "../../lib/custom-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Get the latest qubit task results for all qubits on a chip.

Retrieves the most recent task result for each qubit on the specified chip.
Results include fidelity threshold status based on x90 gate fidelity.

Parameters
----------
chip_id : str
    ID of the chip to fetch results for
task : str
    Name of the task to fetch results for
ctx : ProjectContext
    Project context with user and project information
service : TaskResultService
    Injected task result service

Returns
-------
LatestTaskResultResponse
    Task results for all qubits, keyed by qubit ID

Raises
------
ValueError
    If the chip is not found for the current project
 * @summary Get latest qubit task results
 */
export const getLatestQubitTaskResults = (
  params: GetLatestQubitTaskResultsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<LatestTaskResultResponse>(
    { url: `/task-results/qubits/latest`, method: "GET", params, signal },
    options,
  );
};

export const getGetLatestQubitTaskResultsQueryKey = (
  params?: GetLatestQubitTaskResultsParams,
) => {
  return [`/task-results/qubits/latest`, ...(params ? [params] : [])] as const;
};

export const getGetLatestQubitTaskResultsQueryOptions = <
  TData = Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetLatestQubitTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetLatestQubitTaskResultsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLatestQubitTaskResults>>
  > = ({ signal }) => getLatestQubitTaskResults(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetLatestQubitTaskResultsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLatestQubitTaskResults>>
>;
export type GetLatestQubitTaskResultsQueryError = HTTPValidationError;

export function useGetLatestQubitTaskResults<
  TData = Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetLatestQubitTaskResultsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getLatestQubitTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetLatestQubitTaskResults<
  TData = Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetLatestQubitTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getLatestQubitTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLatestQubitTaskResults<
  TData = Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetLatestQubitTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get latest qubit task results
 */

export function useGetLatestQubitTaskResults<
  TData = Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetLatestQubitTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetLatestQubitTaskResultsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get historical qubit task results for a specific date.

Retrieves task results from a specific historical date using chip history
snapshots. Results are filtered to tasks executed within the specified
day in JST timezone.

Parameters
----------
chip_id : str
    ID of the chip to fetch results for
task : str
    Name of the task to fetch results for
date : str
    Date in YYYYMMDD format (JST timezone)
ctx : ProjectContext
    Project context with user and project information
service : TaskResultService
    Injected task result service

Returns
-------
LatestTaskResultResponse
    Historical task results for all qubits, keyed by qubit ID

Raises
------
ValueError
    If the chip history is not found for the specified date
 * @summary Get historical qubit task results
 */
export const getHistoricalQubitTaskResults = (
  params: GetHistoricalQubitTaskResultsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<LatestTaskResultResponse>(
    { url: `/task-results/qubits/history`, method: "GET", params, signal },
    options,
  );
};

export const getGetHistoricalQubitTaskResultsQueryKey = (
  params?: GetHistoricalQubitTaskResultsParams,
) => {
  return [`/task-results/qubits/history`, ...(params ? [params] : [])] as const;
};

export const getGetHistoricalQubitTaskResultsQueryOptions = <
  TData = Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetHistoricalQubitTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetHistoricalQubitTaskResultsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>
  > = ({ signal }) =>
    getHistoricalQubitTaskResults(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetHistoricalQubitTaskResultsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>
>;
export type GetHistoricalQubitTaskResultsQueryError = HTTPValidationError;

export function useGetHistoricalQubitTaskResults<
  TData = Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetHistoricalQubitTaskResultsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetHistoricalQubitTaskResults<
  TData = Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetHistoricalQubitTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetHistoricalQubitTaskResults<
  TData = Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetHistoricalQubitTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get historical qubit task results
 */

export function useGetHistoricalQubitTaskResults<
  TData = Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetHistoricalQubitTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetHistoricalQubitTaskResultsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get complete task history for a specific qubit.

Retrieves all historical task results for a specific qubit, sorted by
end time in descending order. Useful for tracking calibration trends
over time.

Parameters
----------
qid : str
    Qubit ID to fetch history for
chip_id : str
    ID of the chip containing the qubit
task : str
    Name of the task to fetch history for
ctx : ProjectContext
    Project context with user and project information
service : TaskResultService
    Injected task result service

Returns
-------
TaskHistoryResponse
    All historical task results, keyed by task_id

Raises
------
ValueError
    If the chip is not found for the current project
 * @summary Get qubit task history
 */
export const getQubitTaskHistory = (
  qid: string,
  params: GetQubitTaskHistoryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TaskHistoryResponse>(
    {
      url: `/task-results/qubits/${qid}/history`,
      method: "GET",
      params,
      signal,
    },
    options,
  );
};

export const getGetQubitTaskHistoryQueryKey = (
  qid?: string,
  params?: GetQubitTaskHistoryParams,
) => {
  return [
    `/task-results/qubits/${qid}/history`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetQubitTaskHistoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getQubitTaskHistory>>,
  TError = HTTPValidationError,
>(
  qid: string,
  params: GetQubitTaskHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQubitTaskHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetQubitTaskHistoryQueryKey(qid, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getQubitTaskHistory>>
  > = ({ signal }) => getQubitTaskHistory(qid, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!qid,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getQubitTaskHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetQubitTaskHistoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getQubitTaskHistory>>
>;
export type GetQubitTaskHistoryQueryError = HTTPValidationError;

export function useGetQubitTaskHistory<
  TData = Awaited<ReturnType<typeof getQubitTaskHistory>>,
  TError = HTTPValidationError,
>(
  qid: string,
  params: GetQubitTaskHistoryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQubitTaskHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQubitTaskHistory>>,
          TError,
          Awaited<ReturnType<typeof getQubitTaskHistory>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetQubitTaskHistory<
  TData = Awaited<ReturnType<typeof getQubitTaskHistory>>,
  TError = HTTPValidationError,
>(
  qid: string,
  params: GetQubitTaskHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQubitTaskHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQubitTaskHistory>>,
          TError,
          Awaited<ReturnType<typeof getQubitTaskHistory>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetQubitTaskHistory<
  TData = Awaited<ReturnType<typeof getQubitTaskHistory>>,
  TError = HTTPValidationError,
>(
  qid: string,
  params: GetQubitTaskHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQubitTaskHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get qubit task history
 */

export function useGetQubitTaskHistory<
  TData = Awaited<ReturnType<typeof getQubitTaskHistory>>,
  TError = HTTPValidationError,
>(
  qid: string,
  params: GetQubitTaskHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQubitTaskHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetQubitTaskHistoryQueryOptions(qid, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get the latest coupling task results for all couplings on a chip.

Retrieves the most recent task result for each coupling (qubit pair) on
the specified chip. Results include fidelity threshold status based on
Bell state fidelity.

Parameters
----------
chip_id : str
    ID of the chip to fetch results for
task : str
    Name of the task to fetch results for
ctx : ProjectContext
    Project context with user and project information
service : TaskResultService
    Injected task result service

Returns
-------
LatestTaskResultResponse
    Task results for all couplings, keyed by coupling ID (e.g., "0-1")

Raises
------
ValueError
    If the chip is not found for the current project
 * @summary Get latest coupling task results
 */
export const getLatestCouplingTaskResults = (
  params: GetLatestCouplingTaskResultsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<LatestTaskResultResponse>(
    { url: `/task-results/couplings/latest`, method: "GET", params, signal },
    options,
  );
};

export const getGetLatestCouplingTaskResultsQueryKey = (
  params?: GetLatestCouplingTaskResultsParams,
) => {
  return [
    `/task-results/couplings/latest`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetLatestCouplingTaskResultsQueryOptions = <
  TData = Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetLatestCouplingTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetLatestCouplingTaskResultsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLatestCouplingTaskResults>>
  > = ({ signal }) =>
    getLatestCouplingTaskResults(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetLatestCouplingTaskResultsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLatestCouplingTaskResults>>
>;
export type GetLatestCouplingTaskResultsQueryError = HTTPValidationError;

export function useGetLatestCouplingTaskResults<
  TData = Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetLatestCouplingTaskResultsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getLatestCouplingTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetLatestCouplingTaskResults<
  TData = Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetLatestCouplingTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getLatestCouplingTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLatestCouplingTaskResults<
  TData = Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetLatestCouplingTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get latest coupling task results
 */

export function useGetLatestCouplingTaskResults<
  TData = Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetLatestCouplingTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetLatestCouplingTaskResultsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get historical coupling task results for a specific date.

Retrieves task results from a specific historical date using chip history
snapshots. Results are filtered to tasks executed within the specified
day in JST timezone.

Parameters
----------
chip_id : str
    ID of the chip to fetch results for
task : str
    Name of the task to fetch results for
date : str
    Date in YYYYMMDD format (JST timezone)
ctx : ProjectContext
    Project context with user and project information
service : TaskResultService
    Injected task result service

Returns
-------
LatestTaskResultResponse
    Historical task results for all couplings, keyed by coupling ID

Raises
------
ValueError
    If the chip history is not found for the specified date
 * @summary Get historical coupling task results
 */
export const getHistoricalCouplingTaskResults = (
  params: GetHistoricalCouplingTaskResultsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<LatestTaskResultResponse>(
    { url: `/task-results/couplings/history`, method: "GET", params, signal },
    options,
  );
};

export const getGetHistoricalCouplingTaskResultsQueryKey = (
  params?: GetHistoricalCouplingTaskResultsParams,
) => {
  return [
    `/task-results/couplings/history`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetHistoricalCouplingTaskResultsQueryOptions = <
  TData = Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetHistoricalCouplingTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetHistoricalCouplingTaskResultsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>
  > = ({ signal }) =>
    getHistoricalCouplingTaskResults(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetHistoricalCouplingTaskResultsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>
>;
export type GetHistoricalCouplingTaskResultsQueryError = HTTPValidationError;

export function useGetHistoricalCouplingTaskResults<
  TData = Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetHistoricalCouplingTaskResultsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetHistoricalCouplingTaskResults<
  TData = Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetHistoricalCouplingTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetHistoricalCouplingTaskResults<
  TData = Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetHistoricalCouplingTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get historical coupling task results
 */

export function useGetHistoricalCouplingTaskResults<
  TData = Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetHistoricalCouplingTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetHistoricalCouplingTaskResultsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get complete task history for a specific coupling.

Retrieves all historical task results for a specific coupling (qubit pair),
sorted by end time in descending order. Useful for tracking two-qubit
calibration trends over time.

Parameters
----------
coupling_id : str
    Coupling ID to fetch history for (e.g., "0-1")
chip_id : str
    ID of the chip containing the coupling
task : str
    Name of the task to fetch history for
ctx : ProjectContext
    Project context with user and project information
service : TaskResultService
    Injected task result service

Returns
-------
TaskHistoryResponse
    All historical task results, keyed by task_id

Raises
------
ValueError
    If the chip is not found for the current project
 * @summary Get coupling task history
 */
export const getCouplingTaskHistory = (
  couplingId: string,
  params: GetCouplingTaskHistoryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TaskHistoryResponse>(
    {
      url: `/task-results/couplings/${couplingId}/history`,
      method: "GET",
      params,
      signal,
    },
    options,
  );
};

export const getGetCouplingTaskHistoryQueryKey = (
  couplingId?: string,
  params?: GetCouplingTaskHistoryParams,
) => {
  return [
    `/task-results/couplings/${couplingId}/history`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetCouplingTaskHistoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getCouplingTaskHistory>>,
  TError = HTTPValidationError,
>(
  couplingId: string,
  params: GetCouplingTaskHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCouplingTaskHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetCouplingTaskHistoryQueryKey(couplingId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getCouplingTaskHistory>>
  > = ({ signal }) =>
    getCouplingTaskHistory(couplingId, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!couplingId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getCouplingTaskHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetCouplingTaskHistoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCouplingTaskHistory>>
>;
export type GetCouplingTaskHistoryQueryError = HTTPValidationError;

export function useGetCouplingTaskHistory<
  TData = Awaited<ReturnType<typeof getCouplingTaskHistory>>,
  TError = HTTPValidationError,
>(
  couplingId: string,
  params: GetCouplingTaskHistoryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCouplingTaskHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCouplingTaskHistory>>,
          TError,
          Awaited<ReturnType<typeof getCouplingTaskHistory>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetCouplingTaskHistory<
  TData = Awaited<ReturnType<typeof getCouplingTaskHistory>>,
  TError = HTTPValidationError,
>(
  couplingId: string,
  params: GetCouplingTaskHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCouplingTaskHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCouplingTaskHistory>>,
          TError,
          Awaited<ReturnType<typeof getCouplingTaskHistory>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetCouplingTaskHistory<
  TData = Awaited<ReturnType<typeof getCouplingTaskHistory>>,
  TError = HTTPValidationError,
>(
  couplingId: string,
  params: GetCouplingTaskHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCouplingTaskHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get coupling task history
 */

export function useGetCouplingTaskHistory<
  TData = Awaited<ReturnType<typeof getCouplingTaskHistory>>,
  TError = HTTPValidationError,
>(
  couplingId: string,
  params: GetCouplingTaskHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCouplingTaskHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetCouplingTaskHistoryQueryOptions(
    couplingId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get timeseries task results filtered by tag and parameter.

Retrieves time series data for calibration parameters, optionally filtered
to a specific qubit. Useful for plotting parameter trends over time.

Parameters
----------
chip_id : str
    ID of the chip to fetch results for
tag : str
    Tag to filter tasks by (e.g., calibration category)
parameter : str
    Name of the output parameter to retrieve
start_at : str
    Start time in ISO format for the time range
end_at : str
    End time in ISO format for the time range
ctx : ProjectContext
    Project context with user and project information
service : TaskResultService
    Injected task result service
qid : str | None
    Optional qubit ID to filter results to a specific qubit

Returns
-------
TimeSeriesData
    Time series data keyed by qubit ID, each containing a list of
    parameter values with timestamps
 * @summary Get timeseries task results by tag and parameter
 */
export const getTimeseriesTaskResults = (
  params: GetTimeseriesTaskResultsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TimeSeriesData>(
    { url: `/task-results/timeseries`, method: "GET", params, signal },
    options,
  );
};

export const getGetTimeseriesTaskResultsQueryKey = (
  params?: GetTimeseriesTaskResultsParams,
) => {
  return [`/task-results/timeseries`, ...(params ? [params] : [])] as const;
};

export const getGetTimeseriesTaskResultsQueryOptions = <
  TData = Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetTimeseriesTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTimeseriesTaskResultsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTimeseriesTaskResults>>
  > = ({ signal }) => getTimeseriesTaskResults(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetTimeseriesTaskResultsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTimeseriesTaskResults>>
>;
export type GetTimeseriesTaskResultsQueryError = HTTPValidationError;

export function useGetTimeseriesTaskResults<
  TData = Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetTimeseriesTaskResultsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getTimeseriesTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetTimeseriesTaskResults<
  TData = Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetTimeseriesTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getTimeseriesTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetTimeseriesTaskResults<
  TData = Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetTimeseriesTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get timeseries task results by tag and parameter
 */

export function useGetTimeseriesTaskResults<
  TData = Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
  TError = HTTPValidationError,
>(
  params: GetTimeseriesTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetTimeseriesTaskResultsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Download multiple calibration figures as a ZIP file.

Creates a ZIP archive containing all requested figure files and returns it
as a streaming response.

Parameters
----------
paths : list[str]
    List of absolute file paths to the calibration figures
filename : str
    Filename for the ZIP archive (default: "figures.zip")

Returns
-------
StreamingResponse
    ZIP archive containing all requested files

Raises
------
HTTPException
    400 if no paths are provided or if any path does not exist
 * @summary Download multiple figures as a ZIP file
 */
export const downloadFiguresAsZip = (
  bodyDownloadFiguresAsZip: BodyDownloadFiguresAsZip,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>(
    {
      url: `/task-results/figures/download`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: bodyDownloadFiguresAsZip,
      signal,
    },
    options,
  );
};

export const getDownloadFiguresAsZipMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof downloadFiguresAsZip>>,
    TError,
    { data: BodyDownloadFiguresAsZip },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof downloadFiguresAsZip>>,
  TError,
  { data: BodyDownloadFiguresAsZip },
  TContext
> => {
  const mutationKey = ["downloadFiguresAsZip"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof downloadFiguresAsZip>>,
    { data: BodyDownloadFiguresAsZip }
  > = (props) => {
    const { data } = props ?? {};

    return downloadFiguresAsZip(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DownloadFiguresAsZipMutationResult = NonNullable<
  Awaited<ReturnType<typeof downloadFiguresAsZip>>
>;
export type DownloadFiguresAsZipMutationBody = BodyDownloadFiguresAsZip;
export type DownloadFiguresAsZipMutationError = HTTPValidationError;

/**
 * @summary Download multiple figures as a ZIP file
 */
export const useDownloadFiguresAsZip = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof downloadFiguresAsZip>>,
      TError,
      { data: BodyDownloadFiguresAsZip },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof downloadFiguresAsZip>>,
  TError,
  { data: BodyDownloadFiguresAsZip },
  TContext
> => {
  const mutationOptions = getDownloadFiguresAsZipMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
