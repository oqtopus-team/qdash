/**
 * Generated by orval v7.14.0 üç∫
 * Do not edit manually.
 * QDash API
 * API for QDash
 * OpenAPI spec version: 0.0.1
 */
import { useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  GetCouplingTaskHistoryParams,
  GetHistoricalCouplingTaskResultsParams,
  GetHistoricalQubitTaskResultsParams,
  GetLatestCouplingTaskResultsParams,
  GetLatestQubitTaskResultsParams,
  GetQubitTaskHistoryParams,
  GetTimeseriesTaskResultsParams,
  HTTPValidationError,
  LatestTaskResultResponse,
  TaskHistoryResponse,
  TimeSeriesData,
} from "../../schemas";

import { customInstance } from "../../lib/custom-instance";
import type { ErrorType } from "../../lib/custom-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Fetch latest qubit task results with optional defensive outlier filtering.
 * @summary Get latest qubit task results
 */
export const getLatestQubitTaskResults = (
  params: GetLatestQubitTaskResultsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<LatestTaskResultResponse>(
    { url: `/task-results/qubits/latest`, method: "GET", params, signal },
    options,
  );
};

export const getGetLatestQubitTaskResultsQueryKey = (
  params?: GetLatestQubitTaskResultsParams,
) => {
  return [`/task-results/qubits/latest`, ...(params ? [params] : [])] as const;
};

export const getGetLatestQubitTaskResultsQueryOptions = <
  TData = Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetLatestQubitTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetLatestQubitTaskResultsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLatestQubitTaskResults>>
  > = ({ signal }) => getLatestQubitTaskResults(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetLatestQubitTaskResultsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLatestQubitTaskResults>>
>;
export type GetLatestQubitTaskResultsQueryError =
  ErrorType<HTTPValidationError>;

export function useGetLatestQubitTaskResults<
  TData = Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetLatestQubitTaskResultsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getLatestQubitTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetLatestQubitTaskResults<
  TData = Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetLatestQubitTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getLatestQubitTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLatestQubitTaskResults<
  TData = Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetLatestQubitTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get latest qubit task results
 */

export function useGetLatestQubitTaskResults<
  TData = Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetLatestQubitTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestQubitTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetLatestQubitTaskResultsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Fetch historical qubit task results for a specific date.
 * @summary Get historical qubit task results
 */
export const getHistoricalQubitTaskResults = (
  params: GetHistoricalQubitTaskResultsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<LatestTaskResultResponse>(
    { url: `/task-results/qubits/history`, method: "GET", params, signal },
    options,
  );
};

export const getGetHistoricalQubitTaskResultsQueryKey = (
  params?: GetHistoricalQubitTaskResultsParams,
) => {
  return [`/task-results/qubits/history`, ...(params ? [params] : [])] as const;
};

export const getGetHistoricalQubitTaskResultsQueryOptions = <
  TData = Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetHistoricalQubitTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetHistoricalQubitTaskResultsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>
  > = ({ signal }) =>
    getHistoricalQubitTaskResults(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetHistoricalQubitTaskResultsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>
>;
export type GetHistoricalQubitTaskResultsQueryError =
  ErrorType<HTTPValidationError>;

export function useGetHistoricalQubitTaskResults<
  TData = Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetHistoricalQubitTaskResultsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetHistoricalQubitTaskResults<
  TData = Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetHistoricalQubitTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetHistoricalQubitTaskResults<
  TData = Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetHistoricalQubitTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get historical qubit task results
 */

export function useGetHistoricalQubitTaskResults<
  TData = Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetHistoricalQubitTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalQubitTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetHistoricalQubitTaskResultsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Fetch task history for a specific qubit.
 * @summary Get qubit task history
 */
export const getQubitTaskHistory = (
  qid: string,
  params: GetQubitTaskHistoryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TaskHistoryResponse>(
    {
      url: `/task-results/qubits/${qid}/history`,
      method: "GET",
      params,
      signal,
    },
    options,
  );
};

export const getGetQubitTaskHistoryQueryKey = (
  qid?: string,
  params?: GetQubitTaskHistoryParams,
) => {
  return [
    `/task-results/qubits/${qid}/history`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetQubitTaskHistoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getQubitTaskHistory>>,
  TError = ErrorType<HTTPValidationError>,
>(
  qid: string,
  params: GetQubitTaskHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQubitTaskHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetQubitTaskHistoryQueryKey(qid, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getQubitTaskHistory>>
  > = ({ signal }) => getQubitTaskHistory(qid, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!qid,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getQubitTaskHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetQubitTaskHistoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getQubitTaskHistory>>
>;
export type GetQubitTaskHistoryQueryError = ErrorType<HTTPValidationError>;

export function useGetQubitTaskHistory<
  TData = Awaited<ReturnType<typeof getQubitTaskHistory>>,
  TError = ErrorType<HTTPValidationError>,
>(
  qid: string,
  params: GetQubitTaskHistoryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQubitTaskHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQubitTaskHistory>>,
          TError,
          Awaited<ReturnType<typeof getQubitTaskHistory>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetQubitTaskHistory<
  TData = Awaited<ReturnType<typeof getQubitTaskHistory>>,
  TError = ErrorType<HTTPValidationError>,
>(
  qid: string,
  params: GetQubitTaskHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQubitTaskHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQubitTaskHistory>>,
          TError,
          Awaited<ReturnType<typeof getQubitTaskHistory>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetQubitTaskHistory<
  TData = Awaited<ReturnType<typeof getQubitTaskHistory>>,
  TError = ErrorType<HTTPValidationError>,
>(
  qid: string,
  params: GetQubitTaskHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQubitTaskHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get qubit task history
 */

export function useGetQubitTaskHistory<
  TData = Awaited<ReturnType<typeof getQubitTaskHistory>>,
  TError = ErrorType<HTTPValidationError>,
>(
  qid: string,
  params: GetQubitTaskHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQubitTaskHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetQubitTaskHistoryQueryOptions(qid, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Fetch latest coupling task results.
 * @summary Get latest coupling task results
 */
export const getLatestCouplingTaskResults = (
  params: GetLatestCouplingTaskResultsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<LatestTaskResultResponse>(
    { url: `/task-results/couplings/latest`, method: "GET", params, signal },
    options,
  );
};

export const getGetLatestCouplingTaskResultsQueryKey = (
  params?: GetLatestCouplingTaskResultsParams,
) => {
  return [
    `/task-results/couplings/latest`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetLatestCouplingTaskResultsQueryOptions = <
  TData = Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetLatestCouplingTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetLatestCouplingTaskResultsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLatestCouplingTaskResults>>
  > = ({ signal }) =>
    getLatestCouplingTaskResults(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetLatestCouplingTaskResultsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLatestCouplingTaskResults>>
>;
export type GetLatestCouplingTaskResultsQueryError =
  ErrorType<HTTPValidationError>;

export function useGetLatestCouplingTaskResults<
  TData = Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetLatestCouplingTaskResultsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getLatestCouplingTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetLatestCouplingTaskResults<
  TData = Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetLatestCouplingTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getLatestCouplingTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLatestCouplingTaskResults<
  TData = Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetLatestCouplingTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get latest coupling task results
 */

export function useGetLatestCouplingTaskResults<
  TData = Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetLatestCouplingTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLatestCouplingTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetLatestCouplingTaskResultsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Fetch historical coupling task results for a specific date.
 * @summary Get historical coupling task results
 */
export const getHistoricalCouplingTaskResults = (
  params: GetHistoricalCouplingTaskResultsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<LatestTaskResultResponse>(
    { url: `/task-results/couplings/history`, method: "GET", params, signal },
    options,
  );
};

export const getGetHistoricalCouplingTaskResultsQueryKey = (
  params?: GetHistoricalCouplingTaskResultsParams,
) => {
  return [
    `/task-results/couplings/history`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetHistoricalCouplingTaskResultsQueryOptions = <
  TData = Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetHistoricalCouplingTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetHistoricalCouplingTaskResultsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>
  > = ({ signal }) =>
    getHistoricalCouplingTaskResults(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetHistoricalCouplingTaskResultsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>
>;
export type GetHistoricalCouplingTaskResultsQueryError =
  ErrorType<HTTPValidationError>;

export function useGetHistoricalCouplingTaskResults<
  TData = Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetHistoricalCouplingTaskResultsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetHistoricalCouplingTaskResults<
  TData = Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetHistoricalCouplingTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetHistoricalCouplingTaskResults<
  TData = Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetHistoricalCouplingTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get historical coupling task results
 */

export function useGetHistoricalCouplingTaskResults<
  TData = Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetHistoricalCouplingTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHistoricalCouplingTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetHistoricalCouplingTaskResultsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Fetch task history for a specific coupling.
 * @summary Get coupling task history
 */
export const getCouplingTaskHistory = (
  couplingId: string,
  params: GetCouplingTaskHistoryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TaskHistoryResponse>(
    {
      url: `/task-results/couplings/${couplingId}/history`,
      method: "GET",
      params,
      signal,
    },
    options,
  );
};

export const getGetCouplingTaskHistoryQueryKey = (
  couplingId?: string,
  params?: GetCouplingTaskHistoryParams,
) => {
  return [
    `/task-results/couplings/${couplingId}/history`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetCouplingTaskHistoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getCouplingTaskHistory>>,
  TError = ErrorType<HTTPValidationError>,
>(
  couplingId: string,
  params: GetCouplingTaskHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCouplingTaskHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetCouplingTaskHistoryQueryKey(couplingId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getCouplingTaskHistory>>
  > = ({ signal }) =>
    getCouplingTaskHistory(couplingId, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!couplingId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getCouplingTaskHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetCouplingTaskHistoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCouplingTaskHistory>>
>;
export type GetCouplingTaskHistoryQueryError = ErrorType<HTTPValidationError>;

export function useGetCouplingTaskHistory<
  TData = Awaited<ReturnType<typeof getCouplingTaskHistory>>,
  TError = ErrorType<HTTPValidationError>,
>(
  couplingId: string,
  params: GetCouplingTaskHistoryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCouplingTaskHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCouplingTaskHistory>>,
          TError,
          Awaited<ReturnType<typeof getCouplingTaskHistory>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetCouplingTaskHistory<
  TData = Awaited<ReturnType<typeof getCouplingTaskHistory>>,
  TError = ErrorType<HTTPValidationError>,
>(
  couplingId: string,
  params: GetCouplingTaskHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCouplingTaskHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCouplingTaskHistory>>,
          TError,
          Awaited<ReturnType<typeof getCouplingTaskHistory>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetCouplingTaskHistory<
  TData = Awaited<ReturnType<typeof getCouplingTaskHistory>>,
  TError = ErrorType<HTTPValidationError>,
>(
  couplingId: string,
  params: GetCouplingTaskHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCouplingTaskHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get coupling task history
 */

export function useGetCouplingTaskHistory<
  TData = Awaited<ReturnType<typeof getCouplingTaskHistory>>,
  TError = ErrorType<HTTPValidationError>,
>(
  couplingId: string,
  params: GetCouplingTaskHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCouplingTaskHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetCouplingTaskHistoryQueryOptions(
    couplingId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Fetch timeseries task results by tag and parameter.

If qid is provided, returns data only for that specific qubit.
Otherwise, returns data for all qubits.

Returns
-------
    TimeSeriesData: Time series data for the specified parameters.
 * @summary Get timeseries task results by tag and parameter
 */
export const getTimeseriesTaskResults = (
  params: GetTimeseriesTaskResultsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TimeSeriesData>(
    { url: `/task-results/timeseries`, method: "GET", params, signal },
    options,
  );
};

export const getGetTimeseriesTaskResultsQueryKey = (
  params?: GetTimeseriesTaskResultsParams,
) => {
  return [`/task-results/timeseries`, ...(params ? [params] : [])] as const;
};

export const getGetTimeseriesTaskResultsQueryOptions = <
  TData = Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetTimeseriesTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTimeseriesTaskResultsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTimeseriesTaskResults>>
  > = ({ signal }) => getTimeseriesTaskResults(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetTimeseriesTaskResultsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTimeseriesTaskResults>>
>;
export type GetTimeseriesTaskResultsQueryError = ErrorType<HTTPValidationError>;

export function useGetTimeseriesTaskResults<
  TData = Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetTimeseriesTaskResultsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getTimeseriesTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetTimeseriesTaskResults<
  TData = Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetTimeseriesTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
          TError,
          Awaited<ReturnType<typeof getTimeseriesTaskResults>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetTimeseriesTaskResults<
  TData = Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetTimeseriesTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get timeseries task results by tag and parameter
 */

export function useGetTimeseriesTaskResults<
  TData = Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetTimeseriesTaskResultsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTimeseriesTaskResults>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetTimeseriesTaskResultsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}
