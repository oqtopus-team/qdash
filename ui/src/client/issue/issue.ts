/**
 * Generated by orval v7.14.0 üç∫
 * Do not edit manually.
 * QDash API
 * API for QDash
 * OpenAPI spec version: 0.0.1
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  HTTPValidationError,
  IssueCreate,
  IssueResponse,
  ListIssuesParams,
  ListIssuesResponse,
  SuccessResponse,
} from "../../schemas";

import { customInstance } from "../../lib/custom-instance";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * List all root issues across the project, with reply counts.
 * @summary List all issues across tasks
 */
export const listIssues = (
  params?: ListIssuesParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ListIssuesResponse>(
    { url: `/issues`, method: "GET", params, signal },
    options,
  );
};

export const getListIssuesQueryKey = (params?: ListIssuesParams) => {
  return [`/issues`, ...(params ? [params] : [])] as const;
};

export const getListIssuesQueryOptions = <
  TData = Awaited<ReturnType<typeof listIssues>>,
  TError = HTTPValidationError,
>(
  params?: ListIssuesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listIssues>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListIssuesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listIssues>>> = ({
    signal,
  }) => listIssues(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listIssues>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type ListIssuesQueryResult = NonNullable<
  Awaited<ReturnType<typeof listIssues>>
>;
export type ListIssuesQueryError = HTTPValidationError;

export function useListIssues<
  TData = Awaited<ReturnType<typeof listIssues>>,
  TError = HTTPValidationError,
>(
  params: undefined | ListIssuesParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listIssues>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listIssues>>,
          TError,
          Awaited<ReturnType<typeof listIssues>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useListIssues<
  TData = Awaited<ReturnType<typeof listIssues>>,
  TError = HTTPValidationError,
>(
  params?: ListIssuesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listIssues>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listIssues>>,
          TError,
          Awaited<ReturnType<typeof listIssues>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useListIssues<
  TData = Awaited<ReturnType<typeof listIssues>>,
  TError = HTTPValidationError,
>(
  params?: ListIssuesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listIssues>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary List all issues across tasks
 */

export function useListIssues<
  TData = Awaited<ReturnType<typeof listIssues>>,
  TError = HTTPValidationError,
>(
  params?: ListIssuesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listIssues>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getListIssuesQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get a single root issue by its ID, including reply count.
 * @summary Get a single issue by ID
 */
export const getIssue = (
  issueId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<IssueResponse>(
    { url: `/issues/${issueId}`, method: "GET", signal },
    options,
  );
};

export const getGetIssueQueryKey = (issueId?: string) => {
  return [`/issues/${issueId}`] as const;
};

export const getGetIssueQueryOptions = <
  TData = Awaited<ReturnType<typeof getIssue>>,
  TError = HTTPValidationError,
>(
  issueId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getIssue>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIssueQueryKey(issueId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIssue>>> = ({
    signal,
  }) => getIssue(issueId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!issueId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getIssue>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData>;
  };
};

export type GetIssueQueryResult = NonNullable<
  Awaited<ReturnType<typeof getIssue>>
>;
export type GetIssueQueryError = HTTPValidationError;

export function useGetIssue<
  TData = Awaited<ReturnType<typeof getIssue>>,
  TError = HTTPValidationError,
>(
  issueId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getIssue>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIssue>>,
          TError,
          Awaited<ReturnType<typeof getIssue>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetIssue<
  TData = Awaited<ReturnType<typeof getIssue>>,
  TError = HTTPValidationError,
>(
  issueId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getIssue>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIssue>>,
          TError,
          Awaited<ReturnType<typeof getIssue>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIssue<
  TData = Awaited<ReturnType<typeof getIssue>>,
  TError = HTTPValidationError,
>(
  issueId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getIssue>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get a single issue by ID
 */

export function useGetIssue<
  TData = Awaited<ReturnType<typeof getIssue>>,
  TError = HTTPValidationError,
>(
  issueId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getIssue>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetIssueQueryOptions(issueId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete an issue. Only the author can delete their own issue.
 * @summary Delete an issue
 */
export const deleteIssue = (
  issueId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<SuccessResponse>(
    { url: `/issues/${issueId}`, method: "DELETE" },
    options,
  );
};

export const getDeleteIssueMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteIssue>>,
    TError,
    { issueId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteIssue>>,
  TError,
  { issueId: string },
  TContext
> => {
  const mutationKey = ["deleteIssue"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteIssue>>,
    { issueId: string }
  > = (props) => {
    const { issueId } = props ?? {};

    return deleteIssue(issueId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteIssueMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteIssue>>
>;

export type DeleteIssueMutationError = HTTPValidationError;

/**
 * @summary Delete an issue
 */
export const useDeleteIssue = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteIssue>>,
      TError,
      { issueId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteIssue>>,
  TError,
  { issueId: string },
  TContext
> => {
  const mutationOptions = getDeleteIssueMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * List all replies to a specific issue, sorted by creation time ascending.
 * @summary List replies for an issue
 */
export const getIssueReplies = (
  issueId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<IssueResponse[]>(
    { url: `/issues/${issueId}/replies`, method: "GET", signal },
    options,
  );
};

export const getGetIssueRepliesQueryKey = (issueId?: string) => {
  return [`/issues/${issueId}/replies`] as const;
};

export const getGetIssueRepliesQueryOptions = <
  TData = Awaited<ReturnType<typeof getIssueReplies>>,
  TError = HTTPValidationError,
>(
  issueId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getIssueReplies>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetIssueRepliesQueryKey(issueId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIssueReplies>>> = ({
    signal,
  }) => getIssueReplies(issueId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!issueId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getIssueReplies>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetIssueRepliesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getIssueReplies>>
>;
export type GetIssueRepliesQueryError = HTTPValidationError;

export function useGetIssueReplies<
  TData = Awaited<ReturnType<typeof getIssueReplies>>,
  TError = HTTPValidationError,
>(
  issueId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getIssueReplies>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIssueReplies>>,
          TError,
          Awaited<ReturnType<typeof getIssueReplies>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetIssueReplies<
  TData = Awaited<ReturnType<typeof getIssueReplies>>,
  TError = HTTPValidationError,
>(
  issueId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getIssueReplies>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIssueReplies>>,
          TError,
          Awaited<ReturnType<typeof getIssueReplies>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIssueReplies<
  TData = Awaited<ReturnType<typeof getIssueReplies>>,
  TError = HTTPValidationError,
>(
  issueId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getIssueReplies>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary List replies for an issue
 */

export function useGetIssueReplies<
  TData = Awaited<ReturnType<typeof getIssueReplies>>,
  TError = HTTPValidationError,
>(
  issueId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getIssueReplies>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetIssueRepliesQueryOptions(issueId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Close an issue thread. Only the author or project owner can close.
 * @summary Close an issue
 */
export const closeIssue = (
  issueId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<SuccessResponse>(
    { url: `/issues/${issueId}/close`, method: "PATCH" },
    options,
  );
};

export const getCloseIssueMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof closeIssue>>,
    TError,
    { issueId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof closeIssue>>,
  TError,
  { issueId: string },
  TContext
> => {
  const mutationKey = ["closeIssue"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof closeIssue>>,
    { issueId: string }
  > = (props) => {
    const { issueId } = props ?? {};

    return closeIssue(issueId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CloseIssueMutationResult = NonNullable<
  Awaited<ReturnType<typeof closeIssue>>
>;

export type CloseIssueMutationError = HTTPValidationError;

/**
 * @summary Close an issue
 */
export const useCloseIssue = <TError = HTTPValidationError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof closeIssue>>,
      TError,
      { issueId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof closeIssue>>,
  TError,
  { issueId: string },
  TContext
> => {
  const mutationOptions = getCloseIssueMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Reopen a closed issue thread. Only the author or project owner can reopen.
 * @summary Reopen an issue
 */
export const reopenIssue = (
  issueId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<SuccessResponse>(
    { url: `/issues/${issueId}/reopen`, method: "PATCH" },
    options,
  );
};

export const getReopenIssueMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reopenIssue>>,
    TError,
    { issueId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof reopenIssue>>,
  TError,
  { issueId: string },
  TContext
> => {
  const mutationKey = ["reopenIssue"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reopenIssue>>,
    { issueId: string }
  > = (props) => {
    const { issueId } = props ?? {};

    return reopenIssue(issueId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReopenIssueMutationResult = NonNullable<
  Awaited<ReturnType<typeof reopenIssue>>
>;

export type ReopenIssueMutationError = HTTPValidationError;

/**
 * @summary Reopen an issue
 */
export const useReopenIssue = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof reopenIssue>>,
      TError,
      { issueId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof reopenIssue>>,
  TError,
  { issueId: string },
  TContext
> => {
  const mutationOptions = getReopenIssueMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * List all issues for a task result, sorted by creation time ascending.
 * @summary List issues for a task result
 */
export const getTaskResultIssues = (
  taskId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<IssueResponse[]>(
    { url: `/task-results/${taskId}/issues`, method: "GET", signal },
    options,
  );
};

export const getGetTaskResultIssuesQueryKey = (taskId?: string) => {
  return [`/task-results/${taskId}/issues`] as const;
};

export const getGetTaskResultIssuesQueryOptions = <
  TData = Awaited<ReturnType<typeof getTaskResultIssues>>,
  TError = HTTPValidationError,
>(
  taskId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTaskResultIssues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTaskResultIssuesQueryKey(taskId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTaskResultIssues>>
  > = ({ signal }) => getTaskResultIssues(taskId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!taskId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTaskResultIssues>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetTaskResultIssuesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTaskResultIssues>>
>;
export type GetTaskResultIssuesQueryError = HTTPValidationError;

export function useGetTaskResultIssues<
  TData = Awaited<ReturnType<typeof getTaskResultIssues>>,
  TError = HTTPValidationError,
>(
  taskId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTaskResultIssues>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTaskResultIssues>>,
          TError,
          Awaited<ReturnType<typeof getTaskResultIssues>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useGetTaskResultIssues<
  TData = Awaited<ReturnType<typeof getTaskResultIssues>>,
  TError = HTTPValidationError,
>(
  taskId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTaskResultIssues>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTaskResultIssues>>,
          TError,
          Awaited<ReturnType<typeof getTaskResultIssues>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetTaskResultIssues<
  TData = Awaited<ReturnType<typeof getTaskResultIssues>>,
  TError = HTTPValidationError,
>(
  taskId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTaskResultIssues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary List issues for a task result
 */

export function useGetTaskResultIssues<
  TData = Awaited<ReturnType<typeof getTaskResultIssues>>,
  TError = HTTPValidationError,
>(
  taskId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTaskResultIssues>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetTaskResultIssuesQueryOptions(taskId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new issue on a task result.
 * @summary Create an issue on a task result
 */
export const createIssue = (
  taskId: string,
  issueCreate: IssueCreate,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<IssueResponse>(
    {
      url: `/task-results/${taskId}/issues`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: issueCreate,
      signal,
    },
    options,
  );
};

export const getCreateIssueMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createIssue>>,
    TError,
    { taskId: string; data: IssueCreate },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createIssue>>,
  TError,
  { taskId: string; data: IssueCreate },
  TContext
> => {
  const mutationKey = ["createIssue"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createIssue>>,
    { taskId: string; data: IssueCreate }
  > = (props) => {
    const { taskId, data } = props ?? {};

    return createIssue(taskId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateIssueMutationResult = NonNullable<
  Awaited<ReturnType<typeof createIssue>>
>;
export type CreateIssueMutationBody = IssueCreate;
export type CreateIssueMutationError = HTTPValidationError;

/**
 * @summary Create an issue on a task result
 */
export const useCreateIssue = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createIssue>>,
      TError,
      { taskId: string; data: IssueCreate },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createIssue>>,
  TError,
  { taskId: string; data: IssueCreate },
  TContext
> => {
  const mutationOptions = getCreateIssueMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
