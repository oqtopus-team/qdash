/**
 * Generated by orval v7.5.0 üç∫
 * Do not edit manually.
 * QDash Server
 * API for QDash
 * OpenAPI spec version: 0.0.1
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";
import * as axios from "axios";
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios";
import type {
  Detail,
  ExecuteCalibRequest,
  ExecuteCalibResponse,
  FetchOneQubitCalibSummaryByDateParams,
  HTTPValidationError,
  OneQubitCalibCWInfo,
  OneQubitCalibDailySummaryRequest,
  OneQubitCalibDailySummaryResponse,
  OneQubitCalibHistoryResponse,
  OneQubitCalibResponse,
  OneQubitCalibStatsRequest,
  OneQubitCalibStatsResponse,
  ScheduleCalibRequest,
  ScheduleCalibResponse,
  SuccessResponse,
  TwoQubitCalibDailySummaryModel,
  TwoQubitCalibDailySummaryRequest,
  TwoQubitCalibDailySummaryResponse,
  TwoQubitCalibHistoryResponse,
  TwoQubitCalibResponse,
  TwoQubitCalibStatsRequest,
  TwoQubitCalibStatsResponse,
} from "../../schemas";

/**
 * Executes a calibration by creating a flow run from a deployment.

Args:
    request (ExecuteCalibRequest): The request object containing the calibration data.
    settings (Settings): The application settings.

Returns:
    FLOW_RUN_URL: The URL of the created flow run.

Raises:
    HTTPException: If the execution of the calibration fails.
 * @summary Executes a calibration by creating a flow run from a deployment.
 */
export const executeCalib = (
  executeCalibRequest: ExecuteCalibRequest,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ExecuteCalibResponse>> => {
  return axios.default.post(
    `http://localhost:5715/calibrations`,
    executeCalibRequest,
    options,
  );
};

export const getExecuteCalibMutationOptions = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof executeCalib>>,
    TError,
    { data: ExecuteCalibRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof executeCalib>>,
  TError,
  { data: ExecuteCalibRequest },
  TContext
> => {
  const mutationKey = ["executeCalib"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof executeCalib>>,
    { data: ExecuteCalibRequest }
  > = (props) => {
    const { data } = props ?? {};

    return executeCalib(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ExecuteCalibMutationResult = NonNullable<
  Awaited<ReturnType<typeof executeCalib>>
>;
export type ExecuteCalibMutationBody = ExecuteCalibRequest;
export type ExecuteCalibMutationError = AxiosError<HTTPValidationError>;

/**
 * @summary Executes a calibration by creating a flow run from a deployment.
 */
export const useExecuteCalib = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof executeCalib>>,
    TError,
    { data: ExecuteCalibRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationResult<
  Awaited<ReturnType<typeof executeCalib>>,
  TError,
  { data: ExecuteCalibRequest },
  TContext
> => {
  const mutationOptions = getExecuteCalibMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Fetches all the calibration schedules.
 */
export const fetchAllCalibSchedule = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ScheduleCalibResponse[]>> => {
  return axios.default.get(
    `http://localhost:5715/calibrations/schedule`,
    options,
  );
};

export const getFetchAllCalibScheduleQueryKey = () => {
  return [`http://localhost:5715/calibrations/schedule`] as const;
};

export const getFetchAllCalibScheduleQueryOptions = <
  TData = Awaited<ReturnType<typeof fetchAllCalibSchedule>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchAllCalibSchedule>>,
      TError,
      TData
    >
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFetchAllCalibScheduleQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof fetchAllCalibSchedule>>
  > = ({ signal }) => fetchAllCalibSchedule({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof fetchAllCalibSchedule>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type FetchAllCalibScheduleQueryResult = NonNullable<
  Awaited<ReturnType<typeof fetchAllCalibSchedule>>
>;
export type FetchAllCalibScheduleQueryError = AxiosError<unknown>;

export function useFetchAllCalibSchedule<
  TData = Awaited<ReturnType<typeof fetchAllCalibSchedule>>,
  TError = AxiosError<unknown>,
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchAllCalibSchedule>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof fetchAllCalibSchedule>>,
        TError,
        Awaited<ReturnType<typeof fetchAllCalibSchedule>>
      >,
      "initialData"
    >;
  axios?: AxiosRequestConfig;
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useFetchAllCalibSchedule<
  TData = Awaited<ReturnType<typeof fetchAllCalibSchedule>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchAllCalibSchedule>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof fetchAllCalibSchedule>>,
        TError,
        Awaited<ReturnType<typeof fetchAllCalibSchedule>>
      >,
      "initialData"
    >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useFetchAllCalibSchedule<
  TData = Awaited<ReturnType<typeof fetchAllCalibSchedule>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchAllCalibSchedule>>,
      TError,
      TData
    >
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Fetches all the calibration schedules.
 */

export function useFetchAllCalibSchedule<
  TData = Awaited<ReturnType<typeof fetchAllCalibSchedule>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchAllCalibSchedule>>,
      TError,
      TData
    >
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getFetchAllCalibScheduleQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Schedules a calibration.
 */
export const scheduleCalib = (
  scheduleCalibRequest: ScheduleCalibRequest,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<unknown>> => {
  return axios.default.post(
    `http://localhost:5715/calibrations/schedule`,
    scheduleCalibRequest,
    options,
  );
};

export const getScheduleCalibMutationOptions = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof scheduleCalib>>,
    TError,
    { data: ScheduleCalibRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof scheduleCalib>>,
  TError,
  { data: ScheduleCalibRequest },
  TContext
> => {
  const mutationKey = ["scheduleCalib"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof scheduleCalib>>,
    { data: ScheduleCalibRequest }
  > = (props) => {
    const { data } = props ?? {};

    return scheduleCalib(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ScheduleCalibMutationResult = NonNullable<
  Awaited<ReturnType<typeof scheduleCalib>>
>;
export type ScheduleCalibMutationBody = ScheduleCalibRequest;
export type ScheduleCalibMutationError = AxiosError<HTTPValidationError>;

/**
 * @summary Schedules a calibration.
 */
export const useScheduleCalib = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof scheduleCalib>>,
    TError,
    { data: ScheduleCalibRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationResult<
  Awaited<ReturnType<typeof scheduleCalib>>,
  TError,
  { data: ScheduleCalibRequest },
  TContext
> => {
  const mutationOptions = getScheduleCalibMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Deletes a calibration schedule.
 */
export const deleteCalibSchedule = (
  flowRunId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<unknown>> => {
  return axios.default.delete(
    `http://localhost:5715/calibrations/schedule/${flowRunId}`,
    options,
  );
};

export const getDeleteCalibScheduleMutationOptions = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteCalibSchedule>>,
    TError,
    { flowRunId: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteCalibSchedule>>,
  TError,
  { flowRunId: string },
  TContext
> => {
  const mutationKey = ["deleteCalibSchedule"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteCalibSchedule>>,
    { flowRunId: string }
  > = (props) => {
    const { flowRunId } = props ?? {};

    return deleteCalibSchedule(flowRunId, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteCalibScheduleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteCalibSchedule>>
>;

export type DeleteCalibScheduleMutationError = AxiosError<HTTPValidationError>;

/**
 * @summary Deletes a calibration schedule.
 */
export const useDeleteCalibSchedule = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteCalibSchedule>>,
    TError,
    { flowRunId: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteCalibSchedule>>,
  TError,
  { flowRunId: string },
  TContext
> => {
  const mutationOptions = getDeleteCalibScheduleMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Fetches all the latest one qubit calibrations.

Returns:
    A list of OneQubitCalibResponse objects representing the latest one qubit calibrations.
 * @summary Fetches all the latest one qubit calibrations.
 */
export const fetchAllLatestOneQubitCalib = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<OneQubitCalibResponse[]>> => {
  return axios.default.get(
    `http://localhost:5715/calibrations/latest/one_qubit`,
    options,
  );
};

export const getFetchAllLatestOneQubitCalibQueryKey = () => {
  return [`http://localhost:5715/calibrations/latest/one_qubit`] as const;
};

export const getFetchAllLatestOneQubitCalibQueryOptions = <
  TData = Awaited<ReturnType<typeof fetchAllLatestOneQubitCalib>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchAllLatestOneQubitCalib>>,
      TError,
      TData
    >
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFetchAllLatestOneQubitCalibQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof fetchAllLatestOneQubitCalib>>
  > = ({ signal }) => fetchAllLatestOneQubitCalib({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof fetchAllLatestOneQubitCalib>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type FetchAllLatestOneQubitCalibQueryResult = NonNullable<
  Awaited<ReturnType<typeof fetchAllLatestOneQubitCalib>>
>;
export type FetchAllLatestOneQubitCalibQueryError = AxiosError<unknown>;

export function useFetchAllLatestOneQubitCalib<
  TData = Awaited<ReturnType<typeof fetchAllLatestOneQubitCalib>>,
  TError = AxiosError<unknown>,
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchAllLatestOneQubitCalib>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof fetchAllLatestOneQubitCalib>>,
        TError,
        Awaited<ReturnType<typeof fetchAllLatestOneQubitCalib>>
      >,
      "initialData"
    >;
  axios?: AxiosRequestConfig;
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useFetchAllLatestOneQubitCalib<
  TData = Awaited<ReturnType<typeof fetchAllLatestOneQubitCalib>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchAllLatestOneQubitCalib>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof fetchAllLatestOneQubitCalib>>,
        TError,
        Awaited<ReturnType<typeof fetchAllLatestOneQubitCalib>>
      >,
      "initialData"
    >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useFetchAllLatestOneQubitCalib<
  TData = Awaited<ReturnType<typeof fetchAllLatestOneQubitCalib>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchAllLatestOneQubitCalib>>,
      TError,
      TData
    >
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Fetches all the latest one qubit calibrations.
 */

export function useFetchAllLatestOneQubitCalib<
  TData = Awaited<ReturnType<typeof fetchAllLatestOneQubitCalib>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchAllLatestOneQubitCalib>>,
      TError,
      TData
    >
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getFetchAllLatestOneQubitCalibQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Updates a one qubit calibration CW info.
 */
export const updateAllLatestOneQubitCalibCwInfo = (
  oneQubitCalibCWInfo: OneQubitCalibCWInfo,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<SuccessResponse>> => {
  return axios.default.put(
    `http://localhost:5715/calibrations/latest/one_qubit/cw_info`,
    oneQubitCalibCWInfo,
    options,
  );
};

export const getUpdateAllLatestOneQubitCalibCwInfoMutationOptions = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAllLatestOneQubitCalibCwInfo>>,
    TError,
    { data: OneQubitCalibCWInfo },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAllLatestOneQubitCalibCwInfo>>,
  TError,
  { data: OneQubitCalibCWInfo },
  TContext
> => {
  const mutationKey = ["updateAllLatestOneQubitCalibCwInfo"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAllLatestOneQubitCalibCwInfo>>,
    { data: OneQubitCalibCWInfo }
  > = (props) => {
    const { data } = props ?? {};

    return updateAllLatestOneQubitCalibCwInfo(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateAllLatestOneQubitCalibCwInfoMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateAllLatestOneQubitCalibCwInfo>>
>;
export type UpdateAllLatestOneQubitCalibCwInfoMutationBody =
  OneQubitCalibCWInfo;
export type UpdateAllLatestOneQubitCalibCwInfoMutationError =
  AxiosError<HTTPValidationError>;

/**
 * @summary Updates a one qubit calibration CW info.
 */
export const useUpdateAllLatestOneQubitCalibCwInfo = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAllLatestOneQubitCalibCwInfo>>,
    TError,
    { data: OneQubitCalibCWInfo },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateAllLatestOneQubitCalibCwInfo>>,
  TError,
  { data: OneQubitCalibCWInfo },
  TContext
> => {
  const mutationOptions =
    getUpdateAllLatestOneQubitCalibCwInfoMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Fetches all the latest two qubit calibrations.

Returns:
    list: A list of TwoQubitCalibResponse objects representing the latest two qubit calibrations.
 * @summary Fetches all the latest two qubit calibrations.
 */
export const fetchAllLatestTwoQubitCalib = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<TwoQubitCalibResponse[]>> => {
  return axios.default.get(
    `http://localhost:5715/calibrations/latest/two_qubit`,
    options,
  );
};

export const getFetchAllLatestTwoQubitCalibQueryKey = () => {
  return [`http://localhost:5715/calibrations/latest/two_qubit`] as const;
};

export const getFetchAllLatestTwoQubitCalibQueryOptions = <
  TData = Awaited<ReturnType<typeof fetchAllLatestTwoQubitCalib>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchAllLatestTwoQubitCalib>>,
      TError,
      TData
    >
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFetchAllLatestTwoQubitCalibQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof fetchAllLatestTwoQubitCalib>>
  > = ({ signal }) => fetchAllLatestTwoQubitCalib({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof fetchAllLatestTwoQubitCalib>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type FetchAllLatestTwoQubitCalibQueryResult = NonNullable<
  Awaited<ReturnType<typeof fetchAllLatestTwoQubitCalib>>
>;
export type FetchAllLatestTwoQubitCalibQueryError = AxiosError<unknown>;

export function useFetchAllLatestTwoQubitCalib<
  TData = Awaited<ReturnType<typeof fetchAllLatestTwoQubitCalib>>,
  TError = AxiosError<unknown>,
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchAllLatestTwoQubitCalib>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof fetchAllLatestTwoQubitCalib>>,
        TError,
        Awaited<ReturnType<typeof fetchAllLatestTwoQubitCalib>>
      >,
      "initialData"
    >;
  axios?: AxiosRequestConfig;
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useFetchAllLatestTwoQubitCalib<
  TData = Awaited<ReturnType<typeof fetchAllLatestTwoQubitCalib>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchAllLatestTwoQubitCalib>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof fetchAllLatestTwoQubitCalib>>,
        TError,
        Awaited<ReturnType<typeof fetchAllLatestTwoQubitCalib>>
      >,
      "initialData"
    >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useFetchAllLatestTwoQubitCalib<
  TData = Awaited<ReturnType<typeof fetchAllLatestTwoQubitCalib>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchAllLatestTwoQubitCalib>>,
      TError,
      TData
    >
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Fetches all the latest two qubit calibrations.
 */

export function useFetchAllLatestTwoQubitCalib<
  TData = Awaited<ReturnType<typeof fetchAllLatestTwoQubitCalib>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchAllLatestTwoQubitCalib>>,
      TError,
      TData
    >
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getFetchAllLatestTwoQubitCalibQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Fetches the calibration history for a specific one-qubit calibration by its ID.

Args:
    id (str): The ID of the one-qubit calibration.

Returns:
    list[OneQubitCalibHistoryResponse]: A list of OneQubitCalibHistoryResponse objects representing the calibration history.
 * @summary Fetches the calibration history for a specific one-qubit calibration by its label.
 */
export const fetchOneQubitCalibHistoryByLabel = (
  label: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<OneQubitCalibHistoryResponse[]>> => {
  return axios.default.get(
    `http://localhost:5715/calibrations/history/one_qubit/${label}`,
    options,
  );
};

export const getFetchOneQubitCalibHistoryByLabelQueryKey = (label: string) => {
  return [
    `http://localhost:5715/calibrations/history/one_qubit/${label}`,
  ] as const;
};

export const getFetchOneQubitCalibHistoryByLabelQueryOptions = <
  TData = Awaited<ReturnType<typeof fetchOneQubitCalibHistoryByLabel>>,
  TError = AxiosError<HTTPValidationError>,
>(
  label: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchOneQubitCalibHistoryByLabel>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getFetchOneQubitCalibHistoryByLabelQueryKey(label);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof fetchOneQubitCalibHistoryByLabel>>
  > = ({ signal }) =>
    fetchOneQubitCalibHistoryByLabel(label, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!label,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof fetchOneQubitCalibHistoryByLabel>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type FetchOneQubitCalibHistoryByLabelQueryResult = NonNullable<
  Awaited<ReturnType<typeof fetchOneQubitCalibHistoryByLabel>>
>;
export type FetchOneQubitCalibHistoryByLabelQueryError =
  AxiosError<HTTPValidationError>;

export function useFetchOneQubitCalibHistoryByLabel<
  TData = Awaited<ReturnType<typeof fetchOneQubitCalibHistoryByLabel>>,
  TError = AxiosError<HTTPValidationError>,
>(
  label: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchOneQubitCalibHistoryByLabel>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchOneQubitCalibHistoryByLabel>>,
          TError,
          Awaited<ReturnType<typeof fetchOneQubitCalibHistoryByLabel>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useFetchOneQubitCalibHistoryByLabel<
  TData = Awaited<ReturnType<typeof fetchOneQubitCalibHistoryByLabel>>,
  TError = AxiosError<HTTPValidationError>,
>(
  label: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchOneQubitCalibHistoryByLabel>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchOneQubitCalibHistoryByLabel>>,
          TError,
          Awaited<ReturnType<typeof fetchOneQubitCalibHistoryByLabel>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useFetchOneQubitCalibHistoryByLabel<
  TData = Awaited<ReturnType<typeof fetchOneQubitCalibHistoryByLabel>>,
  TError = AxiosError<HTTPValidationError>,
>(
  label: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchOneQubitCalibHistoryByLabel>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Fetches the calibration history for a specific one-qubit calibration by its label.
 */

export function useFetchOneQubitCalibHistoryByLabel<
  TData = Awaited<ReturnType<typeof fetchOneQubitCalibHistoryByLabel>>,
  TError = AxiosError<HTTPValidationError>,
>(
  label: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchOneQubitCalibHistoryByLabel>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getFetchOneQubitCalibHistoryByLabelQueryOptions(
    label,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Fetches the calibration history for a specific two-qubit calibration by its label.
 */
export const fetchTwoQubitCalibHistoryByLabel = (
  label: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<TwoQubitCalibHistoryResponse[]>> => {
  return axios.default.get(
    `http://localhost:5715/calibrations/history/two_qubit/${label}`,
    options,
  );
};

export const getFetchTwoQubitCalibHistoryByLabelQueryKey = (label: string) => {
  return [
    `http://localhost:5715/calibrations/history/two_qubit/${label}`,
  ] as const;
};

export const getFetchTwoQubitCalibHistoryByLabelQueryOptions = <
  TData = Awaited<ReturnType<typeof fetchTwoQubitCalibHistoryByLabel>>,
  TError = AxiosError<HTTPValidationError>,
>(
  label: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchTwoQubitCalibHistoryByLabel>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getFetchTwoQubitCalibHistoryByLabelQueryKey(label);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof fetchTwoQubitCalibHistoryByLabel>>
  > = ({ signal }) =>
    fetchTwoQubitCalibHistoryByLabel(label, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!label,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof fetchTwoQubitCalibHistoryByLabel>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type FetchTwoQubitCalibHistoryByLabelQueryResult = NonNullable<
  Awaited<ReturnType<typeof fetchTwoQubitCalibHistoryByLabel>>
>;
export type FetchTwoQubitCalibHistoryByLabelQueryError =
  AxiosError<HTTPValidationError>;

export function useFetchTwoQubitCalibHistoryByLabel<
  TData = Awaited<ReturnType<typeof fetchTwoQubitCalibHistoryByLabel>>,
  TError = AxiosError<HTTPValidationError>,
>(
  label: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchTwoQubitCalibHistoryByLabel>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchTwoQubitCalibHistoryByLabel>>,
          TError,
          Awaited<ReturnType<typeof fetchTwoQubitCalibHistoryByLabel>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useFetchTwoQubitCalibHistoryByLabel<
  TData = Awaited<ReturnType<typeof fetchTwoQubitCalibHistoryByLabel>>,
  TError = AxiosError<HTTPValidationError>,
>(
  label: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchTwoQubitCalibHistoryByLabel>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchTwoQubitCalibHistoryByLabel>>,
          TError,
          Awaited<ReturnType<typeof fetchTwoQubitCalibHistoryByLabel>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useFetchTwoQubitCalibHistoryByLabel<
  TData = Awaited<ReturnType<typeof fetchTwoQubitCalibHistoryByLabel>>,
  TError = AxiosError<HTTPValidationError>,
>(
  label: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchTwoQubitCalibHistoryByLabel>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Fetches the calibration history for a specific two-qubit calibration by its label.
 */

export function useFetchTwoQubitCalibHistoryByLabel<
  TData = Awaited<ReturnType<typeof fetchTwoQubitCalibHistoryByLabel>>,
  TError = AxiosError<HTTPValidationError>,
>(
  label: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchTwoQubitCalibHistoryByLabel>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getFetchTwoQubitCalibHistoryByLabelQueryOptions(
    label,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Fetches all the one qubit calibration summaries.
 */
export const fetchAllOneQubitCalibSummary = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<OneQubitCalibDailySummaryResponse[]>> => {
  return axios.default.get(
    `http://localhost:5715/calibrations/one_qubit/summary`,
    options,
  );
};

export const getFetchAllOneQubitCalibSummaryQueryKey = () => {
  return [`http://localhost:5715/calibrations/one_qubit/summary`] as const;
};

export const getFetchAllOneQubitCalibSummaryQueryOptions = <
  TData = Awaited<ReturnType<typeof fetchAllOneQubitCalibSummary>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchAllOneQubitCalibSummary>>,
      TError,
      TData
    >
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFetchAllOneQubitCalibSummaryQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof fetchAllOneQubitCalibSummary>>
  > = ({ signal }) => fetchAllOneQubitCalibSummary({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof fetchAllOneQubitCalibSummary>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type FetchAllOneQubitCalibSummaryQueryResult = NonNullable<
  Awaited<ReturnType<typeof fetchAllOneQubitCalibSummary>>
>;
export type FetchAllOneQubitCalibSummaryQueryError = AxiosError<unknown>;

export function useFetchAllOneQubitCalibSummary<
  TData = Awaited<ReturnType<typeof fetchAllOneQubitCalibSummary>>,
  TError = AxiosError<unknown>,
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchAllOneQubitCalibSummary>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof fetchAllOneQubitCalibSummary>>,
        TError,
        Awaited<ReturnType<typeof fetchAllOneQubitCalibSummary>>
      >,
      "initialData"
    >;
  axios?: AxiosRequestConfig;
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useFetchAllOneQubitCalibSummary<
  TData = Awaited<ReturnType<typeof fetchAllOneQubitCalibSummary>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchAllOneQubitCalibSummary>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof fetchAllOneQubitCalibSummary>>,
        TError,
        Awaited<ReturnType<typeof fetchAllOneQubitCalibSummary>>
      >,
      "initialData"
    >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useFetchAllOneQubitCalibSummary<
  TData = Awaited<ReturnType<typeof fetchAllOneQubitCalibSummary>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchAllOneQubitCalibSummary>>,
      TError,
      TData
    >
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Fetches all the one qubit calibration summaries.
 */

export function useFetchAllOneQubitCalibSummary<
  TData = Awaited<ReturnType<typeof fetchAllOneQubitCalibSummary>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchAllOneQubitCalibSummary>>,
      TError,
      TData
    >
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getFetchAllOneQubitCalibSummaryQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Fetches all the two qubit calibration summaries.
 */
export const fetchAllTwoQubitCalibSummary = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<TwoQubitCalibDailySummaryResponse[]>> => {
  return axios.default.get(
    `http://localhost:5715/calibrations/two_qubit/summary`,
    options,
  );
};

export const getFetchAllTwoQubitCalibSummaryQueryKey = () => {
  return [`http://localhost:5715/calibrations/two_qubit/summary`] as const;
};

export const getFetchAllTwoQubitCalibSummaryQueryOptions = <
  TData = Awaited<ReturnType<typeof fetchAllTwoQubitCalibSummary>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchAllTwoQubitCalibSummary>>,
      TError,
      TData
    >
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFetchAllTwoQubitCalibSummaryQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof fetchAllTwoQubitCalibSummary>>
  > = ({ signal }) => fetchAllTwoQubitCalibSummary({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof fetchAllTwoQubitCalibSummary>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type FetchAllTwoQubitCalibSummaryQueryResult = NonNullable<
  Awaited<ReturnType<typeof fetchAllTwoQubitCalibSummary>>
>;
export type FetchAllTwoQubitCalibSummaryQueryError = AxiosError<unknown>;

export function useFetchAllTwoQubitCalibSummary<
  TData = Awaited<ReturnType<typeof fetchAllTwoQubitCalibSummary>>,
  TError = AxiosError<unknown>,
>(options: {
  query: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchAllTwoQubitCalibSummary>>,
      TError,
      TData
    >
  > &
    Pick<
      DefinedInitialDataOptions<
        Awaited<ReturnType<typeof fetchAllTwoQubitCalibSummary>>,
        TError,
        Awaited<ReturnType<typeof fetchAllTwoQubitCalibSummary>>
      >,
      "initialData"
    >;
  axios?: AxiosRequestConfig;
}): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useFetchAllTwoQubitCalibSummary<
  TData = Awaited<ReturnType<typeof fetchAllTwoQubitCalibSummary>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchAllTwoQubitCalibSummary>>,
      TError,
      TData
    >
  > &
    Pick<
      UndefinedInitialDataOptions<
        Awaited<ReturnType<typeof fetchAllTwoQubitCalibSummary>>,
        TError,
        Awaited<ReturnType<typeof fetchAllTwoQubitCalibSummary>>
      >,
      "initialData"
    >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useFetchAllTwoQubitCalibSummary<
  TData = Awaited<ReturnType<typeof fetchAllTwoQubitCalibSummary>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchAllTwoQubitCalibSummary>>,
      TError,
      TData
    >
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Fetches all the two qubit calibration summaries.
 */

export function useFetchAllTwoQubitCalibSummary<
  TData = Awaited<ReturnType<typeof fetchAllTwoQubitCalibSummary>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchAllTwoQubitCalibSummary>>,
      TError,
      TData
    >
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getFetchAllTwoQubitCalibSummaryQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Fetches a one qubit calibration summary by its date.
 */
export const fetchOneQubitCalibSummaryByDate = (
  date: string,
  params?: FetchOneQubitCalibSummaryByDateParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<OneQubitCalibDailySummaryResponse>> => {
  return axios.default.get(
    `http://localhost:5715/calibrations/one_qubit/summary/${date}`,
    {
      ...options,
      params: { ...params, ...options?.params },
    },
  );
};

export const getFetchOneQubitCalibSummaryByDateQueryKey = (
  date: string,
  params?: FetchOneQubitCalibSummaryByDateParams,
) => {
  return [
    `http://localhost:5715/calibrations/one_qubit/summary/${date}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getFetchOneQubitCalibSummaryByDateQueryOptions = <
  TData = Awaited<ReturnType<typeof fetchOneQubitCalibSummaryByDate>>,
  TError = AxiosError<Detail | HTTPValidationError>,
>(
  date: string,
  params?: FetchOneQubitCalibSummaryByDateParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchOneQubitCalibSummaryByDate>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getFetchOneQubitCalibSummaryByDateQueryKey(date, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof fetchOneQubitCalibSummaryByDate>>
  > = ({ signal }) =>
    fetchOneQubitCalibSummaryByDate(date, params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!date,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof fetchOneQubitCalibSummaryByDate>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type FetchOneQubitCalibSummaryByDateQueryResult = NonNullable<
  Awaited<ReturnType<typeof fetchOneQubitCalibSummaryByDate>>
>;
export type FetchOneQubitCalibSummaryByDateQueryError = AxiosError<
  Detail | HTTPValidationError
>;

export function useFetchOneQubitCalibSummaryByDate<
  TData = Awaited<ReturnType<typeof fetchOneQubitCalibSummaryByDate>>,
  TError = AxiosError<Detail | HTTPValidationError>,
>(
  date: string,
  params: undefined | FetchOneQubitCalibSummaryByDateParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchOneQubitCalibSummaryByDate>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchOneQubitCalibSummaryByDate>>,
          TError,
          Awaited<ReturnType<typeof fetchOneQubitCalibSummaryByDate>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useFetchOneQubitCalibSummaryByDate<
  TData = Awaited<ReturnType<typeof fetchOneQubitCalibSummaryByDate>>,
  TError = AxiosError<Detail | HTTPValidationError>,
>(
  date: string,
  params?: FetchOneQubitCalibSummaryByDateParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchOneQubitCalibSummaryByDate>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchOneQubitCalibSummaryByDate>>,
          TError,
          Awaited<ReturnType<typeof fetchOneQubitCalibSummaryByDate>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useFetchOneQubitCalibSummaryByDate<
  TData = Awaited<ReturnType<typeof fetchOneQubitCalibSummaryByDate>>,
  TError = AxiosError<Detail | HTTPValidationError>,
>(
  date: string,
  params?: FetchOneQubitCalibSummaryByDateParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchOneQubitCalibSummaryByDate>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Fetches a one qubit calibration summary by its date.
 */

export function useFetchOneQubitCalibSummaryByDate<
  TData = Awaited<ReturnType<typeof fetchOneQubitCalibSummaryByDate>>,
  TError = AxiosError<Detail | HTTPValidationError>,
>(
  date: string,
  params?: FetchOneQubitCalibSummaryByDateParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchOneQubitCalibSummaryByDate>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getFetchOneQubitCalibSummaryByDateQueryOptions(
    date,
    params,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Updates a one qubit calibration summary by its date.
 */
export const updateOneQubitCalibSummaryByDate = (
  date: string,
  oneQubitCalibDailySummaryRequest: OneQubitCalibDailySummaryRequest,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<OneQubitCalibDailySummaryResponse>> => {
  return axios.default.patch(
    `http://localhost:5715/calibrations/one_qubit/summary/${date}`,
    oneQubitCalibDailySummaryRequest,
    options,
  );
};

export const getUpdateOneQubitCalibSummaryByDateMutationOptions = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateOneQubitCalibSummaryByDate>>,
    TError,
    { date: string; data: OneQubitCalibDailySummaryRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateOneQubitCalibSummaryByDate>>,
  TError,
  { date: string; data: OneQubitCalibDailySummaryRequest },
  TContext
> => {
  const mutationKey = ["updateOneQubitCalibSummaryByDate"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateOneQubitCalibSummaryByDate>>,
    { date: string; data: OneQubitCalibDailySummaryRequest }
  > = (props) => {
    const { date, data } = props ?? {};

    return updateOneQubitCalibSummaryByDate(date, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateOneQubitCalibSummaryByDateMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateOneQubitCalibSummaryByDate>>
>;
export type UpdateOneQubitCalibSummaryByDateMutationBody =
  OneQubitCalibDailySummaryRequest;
export type UpdateOneQubitCalibSummaryByDateMutationError =
  AxiosError<HTTPValidationError>;

/**
 * @summary Updates a one qubit calibration summary by its date.
 */
export const useUpdateOneQubitCalibSummaryByDate = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateOneQubitCalibSummaryByDate>>,
    TError,
    { date: string; data: OneQubitCalibDailySummaryRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateOneQubitCalibSummaryByDate>>,
  TError,
  { date: string; data: OneQubitCalibDailySummaryRequest },
  TContext
> => {
  const mutationOptions =
    getUpdateOneQubitCalibSummaryByDateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Fetches a two qubit calibration summary by its date.
 */
export const fetchTwoQubitCalibSummaryByDate = (
  date: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<TwoQubitCalibDailySummaryResponse>> => {
  return axios.default.get(
    `http://localhost:5715/calibrations/two_qubit/summary/${date}`,
    options,
  );
};

export const getFetchTwoQubitCalibSummaryByDateQueryKey = (date: string) => {
  return [
    `http://localhost:5715/calibrations/two_qubit/summary/${date}`,
  ] as const;
};

export const getFetchTwoQubitCalibSummaryByDateQueryOptions = <
  TData = Awaited<ReturnType<typeof fetchTwoQubitCalibSummaryByDate>>,
  TError = AxiosError<Detail | HTTPValidationError>,
>(
  date: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchTwoQubitCalibSummaryByDate>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFetchTwoQubitCalibSummaryByDateQueryKey(date);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof fetchTwoQubitCalibSummaryByDate>>
  > = ({ signal }) =>
    fetchTwoQubitCalibSummaryByDate(date, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!date,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof fetchTwoQubitCalibSummaryByDate>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type FetchTwoQubitCalibSummaryByDateQueryResult = NonNullable<
  Awaited<ReturnType<typeof fetchTwoQubitCalibSummaryByDate>>
>;
export type FetchTwoQubitCalibSummaryByDateQueryError = AxiosError<
  Detail | HTTPValidationError
>;

export function useFetchTwoQubitCalibSummaryByDate<
  TData = Awaited<ReturnType<typeof fetchTwoQubitCalibSummaryByDate>>,
  TError = AxiosError<Detail | HTTPValidationError>,
>(
  date: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchTwoQubitCalibSummaryByDate>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchTwoQubitCalibSummaryByDate>>,
          TError,
          Awaited<ReturnType<typeof fetchTwoQubitCalibSummaryByDate>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useFetchTwoQubitCalibSummaryByDate<
  TData = Awaited<ReturnType<typeof fetchTwoQubitCalibSummaryByDate>>,
  TError = AxiosError<Detail | HTTPValidationError>,
>(
  date: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchTwoQubitCalibSummaryByDate>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchTwoQubitCalibSummaryByDate>>,
          TError,
          Awaited<ReturnType<typeof fetchTwoQubitCalibSummaryByDate>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useFetchTwoQubitCalibSummaryByDate<
  TData = Awaited<ReturnType<typeof fetchTwoQubitCalibSummaryByDate>>,
  TError = AxiosError<Detail | HTTPValidationError>,
>(
  date: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchTwoQubitCalibSummaryByDate>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Fetches a two qubit calibration summary by its date.
 */

export function useFetchTwoQubitCalibSummaryByDate<
  TData = Awaited<ReturnType<typeof fetchTwoQubitCalibSummaryByDate>>,
  TError = AxiosError<Detail | HTTPValidationError>,
>(
  date: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchTwoQubitCalibSummaryByDate>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getFetchTwoQubitCalibSummaryByDateQueryOptions(
    date,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Updates a two qubit calibration summary by its date.
 */
export const updateTwoQubitCalibSummaryByDate = (
  date: string,
  twoQubitCalibDailySummaryRequest: TwoQubitCalibDailySummaryRequest,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<TwoQubitCalibDailySummaryModel>> => {
  return axios.default.patch(
    `http://localhost:5715/calibrations/two_qubit/summary/${date}`,
    twoQubitCalibDailySummaryRequest,
    options,
  );
};

export const getUpdateTwoQubitCalibSummaryByDateMutationOptions = <
  TError = AxiosError<Detail | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTwoQubitCalibSummaryByDate>>,
    TError,
    { date: string; data: TwoQubitCalibDailySummaryRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTwoQubitCalibSummaryByDate>>,
  TError,
  { date: string; data: TwoQubitCalibDailySummaryRequest },
  TContext
> => {
  const mutationKey = ["updateTwoQubitCalibSummaryByDate"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTwoQubitCalibSummaryByDate>>,
    { date: string; data: TwoQubitCalibDailySummaryRequest }
  > = (props) => {
    const { date, data } = props ?? {};

    return updateTwoQubitCalibSummaryByDate(date, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateTwoQubitCalibSummaryByDateMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTwoQubitCalibSummaryByDate>>
>;
export type UpdateTwoQubitCalibSummaryByDateMutationBody =
  TwoQubitCalibDailySummaryRequest;
export type UpdateTwoQubitCalibSummaryByDateMutationError = AxiosError<
  Detail | HTTPValidationError
>;

/**
 * @summary Updates a two qubit calibration summary by its date.
 */
export const useUpdateTwoQubitCalibSummaryByDate = <
  TError = AxiosError<Detail | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTwoQubitCalibSummaryByDate>>,
    TError,
    { date: string; data: TwoQubitCalibDailySummaryRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateTwoQubitCalibSummaryByDate>>,
  TError,
  { date: string; data: TwoQubitCalibDailySummaryRequest },
  TContext
> => {
  const mutationOptions =
    getUpdateTwoQubitCalibSummaryByDateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Fetches a calibration figure by its date, qubit, and experiment.
 */
export const fetchCalibFigureByDate = (
  date: string,
  qubit: string,
  path: string,
  exp: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<unknown>> => {
  return axios.default.get(
    `http://localhost:5715/calibrations/figure/${date}/${qubit}/${path}/${exp}`,
    options,
  );
};

export const getFetchCalibFigureByDateQueryKey = (
  date: string,
  qubit: string,
  path: string,
  exp: string,
) => {
  return [
    `http://localhost:5715/calibrations/figure/${date}/${qubit}/${path}/${exp}`,
  ] as const;
};

export const getFetchCalibFigureByDateQueryOptions = <
  TData = Awaited<ReturnType<typeof fetchCalibFigureByDate>>,
  TError = AxiosError<Detail | HTTPValidationError>,
>(
  date: string,
  qubit: string,
  path: string,
  exp: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchCalibFigureByDate>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getFetchCalibFigureByDateQueryKey(date, qubit, path, exp);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof fetchCalibFigureByDate>>
  > = ({ signal }) =>
    fetchCalibFigureByDate(date, qubit, path, exp, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!(date && qubit && path && exp),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof fetchCalibFigureByDate>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type FetchCalibFigureByDateQueryResult = NonNullable<
  Awaited<ReturnType<typeof fetchCalibFigureByDate>>
>;
export type FetchCalibFigureByDateQueryError = AxiosError<
  Detail | HTTPValidationError
>;

export function useFetchCalibFigureByDate<
  TData = Awaited<ReturnType<typeof fetchCalibFigureByDate>>,
  TError = AxiosError<Detail | HTTPValidationError>,
>(
  date: string,
  qubit: string,
  path: string,
  exp: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchCalibFigureByDate>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchCalibFigureByDate>>,
          TError,
          Awaited<ReturnType<typeof fetchCalibFigureByDate>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useFetchCalibFigureByDate<
  TData = Awaited<ReturnType<typeof fetchCalibFigureByDate>>,
  TError = AxiosError<Detail | HTTPValidationError>,
>(
  date: string,
  qubit: string,
  path: string,
  exp: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchCalibFigureByDate>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchCalibFigureByDate>>,
          TError,
          Awaited<ReturnType<typeof fetchCalibFigureByDate>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useFetchCalibFigureByDate<
  TData = Awaited<ReturnType<typeof fetchCalibFigureByDate>>,
  TError = AxiosError<Detail | HTTPValidationError>,
>(
  date: string,
  qubit: string,
  path: string,
  exp: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchCalibFigureByDate>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Fetches a calibration figure by its date, qubit, and experiment.
 */

export function useFetchCalibFigureByDate<
  TData = Awaited<ReturnType<typeof fetchCalibFigureByDate>>,
  TError = AxiosError<Detail | HTTPValidationError>,
>(
  date: string,
  qubit: string,
  path: string,
  exp: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchCalibFigureByDate>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getFetchCalibFigureByDateQueryOptions(
    date,
    qubit,
    path,
    exp,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Fetches one qubit calibration statistics for generating dashboard plots.

Args:
    request (OneQubitCalibStatsRequest): The request object containing the labels.

Returns:
    list: A list of dictionaries representing the calibration statistics for each date.
 * @summary Fetches one qubit calibration stats for dashboard plots.
 */
export const fetchOneQubitCalibStats = (
  oneQubitCalibStatsRequest: OneQubitCalibStatsRequest,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<OneQubitCalibStatsResponse[]>> => {
  return axios.default.post(
    `http://localhost:5715/calibrations/stats/one_qubit`,
    oneQubitCalibStatsRequest,
    options,
  );
};

export const getFetchOneQubitCalibStatsMutationOptions = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof fetchOneQubitCalibStats>>,
    TError,
    { data: OneQubitCalibStatsRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof fetchOneQubitCalibStats>>,
  TError,
  { data: OneQubitCalibStatsRequest },
  TContext
> => {
  const mutationKey = ["fetchOneQubitCalibStats"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof fetchOneQubitCalibStats>>,
    { data: OneQubitCalibStatsRequest }
  > = (props) => {
    const { data } = props ?? {};

    return fetchOneQubitCalibStats(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type FetchOneQubitCalibStatsMutationResult = NonNullable<
  Awaited<ReturnType<typeof fetchOneQubitCalibStats>>
>;
export type FetchOneQubitCalibStatsMutationBody = OneQubitCalibStatsRequest;
export type FetchOneQubitCalibStatsMutationError =
  AxiosError<HTTPValidationError>;

/**
 * @summary Fetches one qubit calibration stats for dashboard plots.
 */
export const useFetchOneQubitCalibStats = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof fetchOneQubitCalibStats>>,
    TError,
    { data: OneQubitCalibStatsRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationResult<
  Awaited<ReturnType<typeof fetchOneQubitCalibStats>>,
  TError,
  { data: OneQubitCalibStatsRequest },
  TContext
> => {
  const mutationOptions = getFetchOneQubitCalibStatsMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Fetches two qubit calibration statistics for generating dashboard plots.

Args:
    request (TwoQubitCalibStatsRequest): The request object containing the labels.

Returns:
    list: A list of dictionaries representing the calibration statistics for each date.
 * @summary Fetches two qubit calibration stats for dashboard plots.
 */
export const fetchTwoQubitCalibStats = (
  twoQubitCalibStatsRequest: TwoQubitCalibStatsRequest,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<TwoQubitCalibStatsResponse[]>> => {
  return axios.default.post(
    `http://localhost:5715/calibrations/stats/two_qubit`,
    twoQubitCalibStatsRequest,
    options,
  );
};

export const getFetchTwoQubitCalibStatsMutationOptions = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof fetchTwoQubitCalibStats>>,
    TError,
    { data: TwoQubitCalibStatsRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof fetchTwoQubitCalibStats>>,
  TError,
  { data: TwoQubitCalibStatsRequest },
  TContext
> => {
  const mutationKey = ["fetchTwoQubitCalibStats"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof fetchTwoQubitCalibStats>>,
    { data: TwoQubitCalibStatsRequest }
  > = (props) => {
    const { data } = props ?? {};

    return fetchTwoQubitCalibStats(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type FetchTwoQubitCalibStatsMutationResult = NonNullable<
  Awaited<ReturnType<typeof fetchTwoQubitCalibStats>>
>;
export type FetchTwoQubitCalibStatsMutationBody = TwoQubitCalibStatsRequest;
export type FetchTwoQubitCalibStatsMutationError =
  AxiosError<HTTPValidationError>;

/**
 * @summary Fetches two qubit calibration stats for dashboard plots.
 */
export const useFetchTwoQubitCalibStats = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof fetchTwoQubitCalibStats>>,
    TError,
    { data: TwoQubitCalibStatsRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationResult<
  Awaited<ReturnType<typeof fetchTwoQubitCalibStats>>,
  TError,
  { data: TwoQubitCalibStatsRequest },
  TContext
> => {
  const mutationOptions = getFetchTwoQubitCalibStatsMutationOptions(options);

  return useMutation(mutationOptions);
};
